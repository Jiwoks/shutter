#! /usr/bin/perl
#Copyright (C) Mario Kemper 2008 <mario.kemper@googlemail.com> Mi, 09 Apr 2008 22:58:09 +0200
#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.


#modules
#--------------------------------------
use utf8;
use strict;
use warnings;
use Gtk2 '-init';
use Gtk2::TrayIcon;
use Gtk2::Gdk::Keysyms;
use Gtk2::Pango;
use Gnome2;
use Gnome2::Wnck;
use Gnome2::GConf;
use Image::Magick;
use File::Copy;
use File::Basename;
use POSIX qw/setlocale strftime/;    # for setlocale()
use Locale::gettext;
use HTTP::Status;
use XML::Simple;
use Data::Dumper;
use Time::HiRes;
use X11::Protocol;
use FindBin '$Bin';

#--------------------------------------

#define constants
#--------------------------------------
use constant TRUE                => 1;
use constant FALSE               => 0;
use constant BRANCH              => "Rev.206";
use constant PPA_VERSION         => "ppa1";
use constant GSCROT_NAME         => "GScrot";
use constant GSCROT_VERSION      => "v0.62";
use constant GSCROT_VERSION_FULL => BRANCH . " - " . PPA_VERSION;

#--------------------------------------

#configure path settings
#--------------------------------------
$Bin =~ m/(.*)\//;
my $gscrot_root = $1;
my $gscrot_path = $Bin . "/gscrot";
$ENV{ 'GSCROT_ROOT' } = $gscrot_root;    #need by some plugins

#--------------------------------------

#command line parameter
#--------------------------------------
my $debug_cparam    = FALSE;
my $min_cparam      = FALSE;
my @args            = @ARGV;
my $start_with      = undef;
my $gnome_web_photo = TRUE;
my $gtklp           = TRUE;

#--------------------------------------

#intl using gettext
#--------------------------------------
setlocale( LC_MESSAGES, "" );
my $d = Locale::gettext->domain( "gscrot" );
$d->dir( $gscrot_root . "/share/locale" );
$ENV{ 'GSCROT_INTL' } = $gscrot_root . "/share/locale";

#--------------------------------------

#data structures
#--------------------------------------
my %gm_programs;    #hash to store program infos
my %plugins;        #hash to store plugin infos
my %accounts;       #hash to store account infos
my %settings;       #hash to store settings
&fct_init;
&fct_check_installed_programs;
&fct_check_installed_plugins;
&fct_load_accounts;

#--------------------------------------

#custom modules load at runtime
#--------------------------------------
require lib;
import lib "$gscrot_root/share/gscrot/resources/modules";
require GScrot::ImageBanana;
import GScrot::ImageBanana;
require GScrot::UbuntuPics;
import GScrot::UbuntuPics;
require GScrot::ImageShack;
import GScrot::ImageShack;
require GScrot::Draw;
import GScrot::Draw;

#--------------------------------------

#signal-handler
$SIG{ USR1 }  = sub { &evt_take_screenshot( 'global_keybinding', 'raw' ) };
$SIG{ USR2 }  = sub { &evt_take_screenshot( 'global_keybinding', 'window' ) };
$SIG{ RTMIN } = sub { &evt_take_screenshot( 'global_keybinding', 'select' ) };
$SIG{ RTMAX } = sub { &evt_take_screenshot( 'global_keybinding', 'section' ) };

#screen
my $x = X11::Protocol->new( $ENV{ 'DISPLAY' } );
if ( $debug_cparam ) {
	my @extensions = $x->ListExtensions;
	foreach ( @extensions ) {
		print $_. "\n";
	}
}

#$x->init_extension( 'SHAPE' ) or die "Could not initialize X11 EXTENSION SHAPE";
my $screen = Gnome2::Wnck::Screen->get_default;
$screen->force_update();
my $gdk_screen       = Gtk2::Gdk::Screen->get_default;
my @workspaces       = undef;
my %children         = ();
my $active_workspace = $screen->get_active_workspace;

#hash of screenshots during session
my %session_screens;
my %session_start_screen;

#Clipboard
my $clipboard = Gtk2::Clipboard->get( Gtk2::Gdk->SELECTION_CLIPBOARD );

#gui
#--------------------------------------

my $window = Gtk2::Window->new( 'toplevel' );
$window->set_title( GSCROT_NAME . " " . GSCROT_VERSION );
$window->set_default_icon(
						   Gtk2::Gdk::Pixbuf->new_from_file_at_size(
										"$gscrot_root/share/pixmaps/gscrot.svg",
										500, 500
						   )
						 );
$window->signal_connect( 'delete-event' => \&evt_delete_window );
$window->set_border_width( 0 );
$window->set_resizable( 1 );
$window->set_position( 'center' );
$window->set_default_size( 650, 500 );

my $is_in_tray = FALSE;

my $accel_group = Gtk2::AccelGroup->new;
$window->add_accel_group( $accel_group );

my $notebook = Gtk2::Notebook->new;
$notebook->set( homogeneous => 1 );

#create first page etc.
&fct_create_session_notebook;

my $statusbar = Gtk2::Statusbar->new;

#arrange settings in notebook
my $notebook_settings = Gtk2::Notebook->new;
my $settings_dialog =
	Gtk2::Dialog->new( GSCROT_NAME . " - " . $d->get( "Settings" ),
					   $window,
					   [ qw/modal destroy-with-parent/ ],
					   'gtk-close' => 'close' );


my $vbox                = Gtk2::VBox->new( FALSE, 0 );
my $vbox_settings       = Gtk2::VBox->new( FALSE, 10 );
my $vbox_basic          = Gtk2::VBox->new( FALSE, 10 );
my $vbox_extras         = Gtk2::VBox->new( FALSE, 10 );
my $vbox_behavior       = Gtk2::VBox->new( FALSE, 10 );
my $vbox_plugins        = Gtk2::VBox->new( FALSE, 10 );
my $vbox_accounts       = Gtk2::VBox->new( FALSE, 10 );
my $file_vbox           = Gtk2::VBox->new( FALSE, 0 );
my $save_vbox           = Gtk2::VBox->new( FALSE, 0 );
my $behavior_vbox       = Gtk2::VBox->new( FALSE, 0 );
my $keybinding_vbox     = Gtk2::VBox->new( FALSE, 0 );
my $actions_vbox        = Gtk2::VBox->new( FALSE, 0 );
my $capture_vbox        = Gtk2::VBox->new( FALSE, 0 );
my $effects_vbox        = Gtk2::VBox->new( FALSE, 0 );
my $accounts_vbox       = Gtk2::VBox->new( FALSE, 0 );
my $profiles_box        = Gtk2::HBox->new( FALSE, 0 );
my $scale_box           = Gtk2::HBox->new( TRUE,  0 );
my $delay_box           = Gtk2::HBox->new( TRUE,  0 );
my $delay_box2          = Gtk2::HBox->new( FALSE, 0 );
my $thumbnail_box       = Gtk2::HBox->new( TRUE,  0 );
my $thumbnail_box2      = Gtk2::HBox->new( FALSE, 0 );
my $resize_operator_box = Gtk2::HBox->new( TRUE,  0 );
my $filename_box        = Gtk2::HBox->new( TRUE,  0 );
my $progname_box        = Gtk2::HBox->new( TRUE,  0 );
my $progname_box2       = Gtk2::HBox->new( FALSE, 0 );
my $im_colors_box       = Gtk2::HBox->new( TRUE,  0 );
my $im_colors_box2      = Gtk2::HBox->new( FALSE, 0 );
my $filetype_box        = Gtk2::HBox->new( TRUE,  0 );
my $saveDir_box         = Gtk2::HBox->new( TRUE,  0 );
my $behavior_box        = Gtk2::HBox->new( TRUE,  0 );
my $key_box             = Gtk2::HBox->new( TRUE,  0 );
my $key_box2            = Gtk2::HBox->new( FALSE, 0 );
my $key_sel_box         = Gtk2::HBox->new( TRUE,  0 );
my $key_sel_box2        = Gtk2::HBox->new( FALSE, 0 );
my $border_box          = Gtk2::HBox->new( TRUE,  0 );
my $cursor_box          = Gtk2::HBox->new( TRUE,  0 );

$window->add( $vbox );

#--------------------------------------

#load settings
my $settings_xml = &fct_load_settings( "start", "start" );

#load last profile
if ( defined $settings_xml->{ 'general' }->{ 'last_profile' } ) {
	if ( $settings_xml->{ 'general' }->{ 'last_profile' } != -1 ) {
		$settings_xml =
			&fct_load_settings( "start", "start",
						$settings_xml->{ 'general' }->{ 'last_profile_name' } );
	}
}

#menu
#--------------------------------------
my $menubar = Gtk2::MenuBar->new();

#file
my $menu_file     = Gtk2::Menu->new();
my $menuitem_file = Gtk2::MenuItem->new_with_mnemonic( $d->get( "_File" ) );
my $menuitem_open = Gtk2::ImageMenuItem->new_from_stock( 'gtk-open' );
$menuitem_open->add_accelerator( "activate", $accel_group,
								 $Gtk2::Gdk::Keysyms{ O },
								 qw/control-mask/, qw/visible/ );
$menu_file->append( $menuitem_open );
$menuitem_open->signal_connect( "activate", \&evt_open, 'menu_open' );

$menu_file->append( Gtk2::SeparatorMenuItem->new );

my $menuitem_save_as = Gtk2::ImageMenuItem->new_from_stock( 'gtk-save-as' );
$menuitem_save_as->set_sensitive( FALSE );
$menuitem_save_as->add_accelerator(
									"activate",
									$accel_group,
									Gtk2::Accelerator->parse(
															 "<Shift><Control>S"
															),
									qw/visible/
								  );
$menu_file->append( $menuitem_save_as );
$menuitem_save_as->signal_connect( "activate", \&evt_save_as, 'menu_save_as' );

$menu_file->append( Gtk2::SeparatorMenuItem->new );

my $menuitem_close = Gtk2::ImageMenuItem->new_from_stock( 'gtk-close' );
$menuitem_close->set_sensitive( FALSE );
$menuitem_close->add_accelerator( "activate", $accel_group,
								  Gtk2::Accelerator->parse( "<Control>W" ),
								  qw/visible/ );
$menu_file->append( $menuitem_close );
$menuitem_close->signal_connect( "activate", \&evt_close, 'menu_close' );

my $menuitem_close_all =
	Gtk2::ImageMenuItem->new_with_label( $d->get( "Close all" ) );
$menuitem_close_all->set_image(
						   Gtk2::Image->new_from_stock( 'gtk-close', 'menu' ) );
$menuitem_close_all->add_accelerator(
									  "activate",
									  $accel_group,
									  Gtk2::Accelerator->parse(
															 "<Shift><Control>W"
									  ),
									  qw/visible/
									);
$menu_file->append( $menuitem_close_all );
$menuitem_close_all->signal_connect( "activate", \&evt_close_all,
									 'menu_close_all' );

$menu_file->append( Gtk2::SeparatorMenuItem->new );

my $menuitem_quit = Gtk2::ImageMenuItem->new_from_stock( 'gtk-quit' );
$menuitem_quit->add_accelerator( "activate", $accel_group,
								 $Gtk2::Gdk::Keysyms{ Q },
								 qw/control-mask/, qw/visible/ );
$menu_file->append( $menuitem_quit );
$menuitem_quit->signal_connect( "activate", \&evt_delete_window, 'menu_quit' );

$menuitem_file->set_submenu( $menu_file );
$menubar->append( $menuitem_file );

#end file
#edit
my $menu_edit = Gtk2::Menu->new();
my $menuitem_settings =
	Gtk2::ImageMenuItem->new_from_stock( 'gtk-preferences' );
$menuitem_settings->add_accelerator( "activate", $accel_group,
									 $Gtk2::Gdk::Keysyms{ P },
									 qw/mod1-mask/, qw/visible/ );
$menu_edit->append( $menuitem_settings );
$menuitem_settings->signal_connect( "activate", \&evt_show_settings,
									'exp_settings_menu' );
my $menuitem_edit = Gtk2::MenuItem->new_with_mnemonic( $d->get( "_Edit" ) );
$menuitem_edit->set_submenu( $menu_edit );
$menubar->append( $menuitem_edit );

#end edit
#actions
my $menu_actions       = Gtk2::Menu->new();
my $menuitem_selection = Gtk2::ImageMenuItem->new( $d->get( "Selection" ) );
$menuitem_selection->set_image(
			  Gtk2::Image->new_from_pixbuf(
				  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					  "$gscrot_root/share/gscrot/resources/icons/selection.svg",
					  Gtk2::IconSize->lookup( 'menu' )
				  )
			  )
);
$menuitem_selection->add_accelerator( "activate", $accel_group,
									  $Gtk2::Gdk::Keysyms{ S },
									  qw/mod1-mask/, qw/visible/ );
$menu_actions->append( $menuitem_selection );
$menuitem_selection->signal_connect( "activate", \&evt_take_screenshot,
									 'select' );
$menu_actions->append( Gtk2::SeparatorMenuItem->new );
my $menuitem_raw = Gtk2::ImageMenuItem->new( $d->get( "Fullscreen" ) );
$menuitem_raw->set_image(
			 Gtk2::Image->new_from_pixbuf(
				 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/fullscreen.svg",
					 Gtk2::IconSize->lookup( 'menu' )
				 )
			 )
);
$menuitem_raw->add_accelerator( "activate", $accel_group,
								$Gtk2::Gdk::Keysyms{ F },
								qw/mod1-mask/, qw/visible/ );
$menu_actions->append( $menuitem_raw );
$menuitem_raw->signal_connect( "activate", \&evt_take_screenshot, 'raw' );
$menu_actions->append( Gtk2::SeparatorMenuItem->new );
my $menuitem_window = Gtk2::ImageMenuItem->new( $d->get( "Window" ) );
$menuitem_window->set_image(
			 Gtk2::Image->new_from_pixbuf(
				 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/sel_window.svg",
					 Gtk2::IconSize->lookup( 'menu' )
				 )
			 )
);
$menuitem_window->add_accelerator( "activate", $accel_group,
								   $Gtk2::Gdk::Keysyms{ W },
								   qw/mod1-mask/, qw/visible/ );
$menu_actions->append( $menuitem_window );
$menuitem_window->signal_connect( "activate", \&evt_take_screenshot, 'window' );
my $menuitem_window_sect = Gtk2::ImageMenuItem->new( $d->get( "Section" ) );
$menuitem_window_sect->set_image(
	 Gtk2::Image->new_from_pixbuf(
		 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
			 "$gscrot_root/share/gscrot/resources/icons/sel_window_section.svg",
			 Gtk2::IconSize->lookup( 'menu' )
		 )
	 )
);
$menuitem_window_sect->add_accelerator(
										"activate",
										$accel_group,
										$Gtk2::Gdk::Keysyms{ S },
										qw/shift-mask/,
										qw/visible/
									  );
$menu_actions->append( $menuitem_window_sect );
$menuitem_window_sect->signal_connect( "activate", \&evt_take_screenshot,
									   'section' );
$menu_actions->append( Gtk2::SeparatorMenuItem->new );
my $menuitem_web = Gtk2::ImageMenuItem->new( $d->get( "Web" ) );
$menuitem_web->set_sensitive( $gnome_web_photo );
$menuitem_web->set_image(
			  Gtk2::Image->new_from_pixbuf(
				  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					  "$gscrot_root/share/gscrot/resources/icons/web_image.svg",
					  Gtk2::IconSize->lookup( 'menu' )
				  )
			  )
);
$menuitem_web->add_accelerator( "activate", $accel_group,
								$Gtk2::Gdk::Keysyms{ W },
								qw/shift-mask/, qw/visible/ );
$menu_actions->append( $menuitem_web );
$menuitem_web->signal_connect( "activate", \&evt_take_screenshot, 'web' );
my $menuitem_action =
	Gtk2::MenuItem->new_with_mnemonic( $d->get( "_Actions" ) );
$menuitem_action->set_submenu( $menu_actions );
$menubar->append( $menuitem_action );

#end actions
#session
my $menu_session = Gtk2::Menu->new();

my $menuitem_back = Gtk2::ImageMenuItem->new_from_stock( 'gtk-go-back' );
$menuitem_back->add_accelerator( "activate", $accel_group,
								 $Gtk2::Gdk::Keysyms{ Left },
								 qw/mod1-mask/, qw/visible/ );
$menu_session->append( $menuitem_back );
$menuitem_back->signal_connect( "activate", \&evt_navigate, 'previous' );
my $menuitem_forward = Gtk2::ImageMenuItem->new_from_stock( 'gtk-go-forward' );
$menuitem_forward->add_accelerator( "activate", $accel_group,
									$Gtk2::Gdk::Keysyms{ Right },
									qw/mod1-mask/, qw/visible/ );
$menu_session->append( $menuitem_forward );
$menuitem_forward->signal_connect( "activate", \&evt_navigate, 'forward' );

$menu_session->append( Gtk2::SeparatorMenuItem->new );

my $menuitem_first = Gtk2::ImageMenuItem->new_from_stock( 'gtk-goto-first' );
$menuitem_first->add_accelerator( "activate", $accel_group,
								  $Gtk2::Gdk::Keysyms{ Home },
								  qw/mod1-mask/, qw/visible/ );
$menu_session->append( $menuitem_first );
$menuitem_first->signal_connect( "activate", \&evt_navigate, 'first' );

my $menuitem_last = Gtk2::ImageMenuItem->new_from_stock( 'gtk-goto-last' );
$menuitem_last->add_accelerator( "activate", $accel_group,
								 $Gtk2::Gdk::Keysyms{ End },
								 qw/mod1-mask/, qw/visible/ );
$menu_session->append( $menuitem_last );
$menuitem_last->signal_connect( "activate", \&evt_navigate, 'last' );

my $menuitem_session = Gtk2::MenuItem->new_with_mnemonic( $d->get( "_Go" ) );
$menuitem_session->set_submenu( $menu_session );
$menubar->append( $menuitem_session );

#end session
#help
my $menu_help = Gtk2::Menu->new();
my $menuitem_question =
	Gtk2::ImageMenuItem->new( $d->get( "Get Help Online ..." ) );
$menuitem_question->set_image(
			   Gtk2::Image->new_from_pixbuf(
				   Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					   "$gscrot_root/share/gscrot/resources/icons/lpi-help.png",
					   Gtk2::IconSize->lookup( 'menu' )
				   )
			   )
);

$menu_help->append( $menuitem_question );

my $menuitem_translate =
	Gtk2::ImageMenuItem->new( $d->get( "Translate this Application ..." ) );
$menuitem_translate->set_image(
		  Gtk2::Image->new_from_pixbuf(
			  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
				  "$gscrot_root/share/gscrot/resources/icons/lpi-translate.png",
				  Gtk2::IconSize->lookup( 'menu' )
			  )
		  )
);

$menu_help->append( $menuitem_translate );
$menuitem_translate->signal_connect( "activate", \&evt_translate, $window );

$menuitem_question->signal_connect( "activate", \&evt_question, $window );
my $menuitem_bug = Gtk2::ImageMenuItem->new( $d->get( "Report a Problem" ) );
$menuitem_bug->set_image(
				Gtk2::Image->new_from_pixbuf(
					Gtk2::Gdk::Pixbuf->new_from_file_at_size(
						"$gscrot_root/share/gscrot/resources/icons/lpi-bug.png",
						Gtk2::IconSize->lookup( 'menu' )
					)
				)
);

$menu_help->append( $menuitem_bug );
$menuitem_bug->signal_connect( "activate", \&evt_bug, $window );

$menu_help->append( Gtk2::SeparatorMenuItem->new );
my $menuitem_about = Gtk2::ImageMenuItem->new_from_stock( 'gtk-about' );

$menuitem_about->add_accelerator( "activate", $accel_group,
								  $Gtk2::Gdk::Keysyms{ I },
								  qw/control-mask/, qw/visible/ );
$menu_help->append( $menuitem_about );
$menuitem_about->signal_connect( "activate", \&evt_about, $window );
my $menuitem_help = Gtk2::MenuItem->new_with_mnemonic( $d->get( "_Help" ) );
$menuitem_help->set_submenu( $menu_help );
$menubar->append( $menuitem_help );

#help
$vbox->pack_start( $menubar, FALSE, TRUE, 0 );

#--------------------------------------

#button selection
#--------------------------------------
my $image_select =
	Gtk2::Image->new_from_pixbuf(
				  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					  "$gscrot_root/share/gscrot/resources/icons/selection.svg",
					  Gtk2::IconSize->lookup( 'large-toolbar' )
				  )
	);
my $button_select_menu =
	Gtk2::MenuToolButton->new( $image_select, $d->get( "Selection" ) );
$button_select_menu->signal_connect( 'clicked' => \&evt_take_screenshot,
									 'select' );
my $zoom_active = undef;
my ( $zoom_size1, $zoom_size2, $zoom_size3 ) = undef;
$button_select_menu->set_menu( &fct_ret_sel_menu );
my $tooltip_select = Gtk2::Tooltips->new;
$tooltip_select->set_tip(
						  $button_select_menu,
						  $d->get(
							  "Draw a rectangular capture area with your mouse\nto select a specified screen area"
						  )
						);

#--------------------------------------

#button full screen
#--------------------------------------
my $image_raw =
	Gtk2::Image->new_from_pixbuf(
				 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/fullscreen.svg",
					 Gtk2::IconSize->lookup( 'large-toolbar' )
				 )
	);
my $button_raw_menu =
	Gtk2::MenuToolButton->new( $image_raw, $d->get( "Fullscreen" ) );
$button_raw_menu->signal_connect( 'clicked' => \&evt_take_screenshot, 'raw' );
$button_raw_menu->set_menu( &fct_ret_workspace_menu );
$button_raw_menu->signal_connect( 'show-menu' => \&fct_ret_workspace_menu );
my $tooltip_raw = Gtk2::Tooltips->new;
$tooltip_raw->set_tip( $button_raw_menu,
					   $d->get( "Take a screenshot of your whole desktop" ) );
$button_raw_menu->set_arrow_tooltip( Gtk2::Tooltips->new,
									 $d->get( "Capture a specific workspace" ),
									 'arrow' );

#--------------------------------------

#button window
#--------------------------------------
my $image_window =
	Gtk2::Image->new_from_pixbuf(
				 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/sel_window.svg",
					 Gtk2::IconSize->lookup( 'large-toolbar' )
				 )
	);
my $button_window_menu =
	Gtk2::MenuToolButton->new( $image_window, $d->get( "Window" ) );
$button_window_menu->signal_connect( 'clicked' => \&evt_take_screenshot,
									 'window' );
$button_window_menu->set_menu( &fct_ret_window_menu );
$button_window_menu->signal_connect( 'show-menu' => \&fct_ret_window_menu );
my $tooltip_window = Gtk2::Tooltips->new;
$tooltip_window->set_tip( $button_window_menu,
						  $d->get( "Select a window with your mouse" ) );
$button_window_menu->set_arrow_tooltip(
									Gtk2::Tooltips->new,
									$d->get(
										"Take a screenshot of a specific window"
									),
									'arrow'
);

#--------------------------------------

#button section
#--------------------------------------
my $image_window_sect =
	Gtk2::Image->new_from_pixbuf(
		 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
			 "$gscrot_root/share/gscrot/resources/icons/sel_window_section.svg",
			 Gtk2::IconSize->lookup( 'large-toolbar' )
		 )
	);
my $button_window_sect =
	Gtk2::ToolButton->new( $image_window_sect, $d->get( "Section" ) );
$button_window_sect->signal_connect( 'clicked' => \&evt_take_screenshot,
									 'section' );
my $tooltip_window_sect = Gtk2::Tooltips->new;
$tooltip_window_sect->set_tip(
							   $button_window_sect,
							   $d->get(
								   "Captures only a section of the window. You will be able to select any child window by moving the mouse over it"
							   )
							 );

#--------------------------------------

#button web
#--------------------------------------
my $image_web =
	Gtk2::Image->new_from_pixbuf(
				  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					  "$gscrot_root/share/gscrot/resources/icons/web_image.svg",
					  Gtk2::IconSize->lookup( 'large-toolbar' )
				  )
	);
my $button_web_menu = Gtk2::MenuToolButton->new( $image_web, $d->get( "Web" ) );
$button_web_menu->signal_connect( 'clicked' => \&evt_take_screenshot, 'web' );
$button_web_menu->set_menu( &fct_ret_web_menu );
$button_web_menu->signal_connect( 'show-menu' => \&fct_ret_web_menu );
my $tooltip_web = Gtk2::Tooltips->new;

if ( $gnome_web_photo ) {
	$tooltip_web->set_tip( $button_web_menu,
						   $d->get( "Take a screenshot of a website" ) );
	$button_web_menu->set_arrow_tooltip( Gtk2::Tooltips->new,
				  $d->get( "Set up a connection timeout (seconds)" ), 'arrow' );
} else {
	$tooltip_web->set_tip(
						   $button_web_menu,
						   $d->get(
							   "gnome-web-photo needs to be installed for this feature"
						   )
						 );
	$button_web_menu->set_arrow_tooltip( Gtk2::Tooltips->new,
			$d->get( "gnome-web-photo needs to be installed for this feature" ),
			'arrow' );
	$button_web_menu->set_sensitive( $gnome_web_photo );
}


#--------------------------------------

#create the toolbar
my $toolbar = Gtk2::Toolbar->new;
$toolbar->set_show_arrow( TRUE );
$toolbar->set_style( 'both' );
$toolbar->set_icon_size( 'large-toolbar' );
$toolbar->insert( $button_select_menu,          -1 );
$toolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
$toolbar->insert( $button_raw_menu,             -1 );
$toolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
$toolbar->insert( $button_window_menu,          -1 );
$toolbar->insert( $button_window_sect,          -1 );
$toolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
$toolbar->insert( $button_web_menu,             -1 );
$toolbar->set_size_request( 450, -1 );

#a detachable toolbar
my $handlebox = Gtk2::HandleBox->new;
$handlebox->add( $toolbar );
$vbox->pack_start( $handlebox, FALSE, TRUE, 0 );

#trayicon
#--------------------------------------
my $icon = Gtk2::Image->new_from_pixbuf(
									Gtk2::Gdk::Pixbuf->new_from_file_at_size(
										"$gscrot_root/share/pixmaps/gscrot.svg",
										24, 24
									)
);
my $eventbox = Gtk2::EventBox->new;
$eventbox->add( $icon );
my $tray = Gtk2::TrayIcon->new( 'gscrot TrayIcon' );
$tray->add( $eventbox );

#tooltip
my $tooltip_tray = Gtk2::Tooltips->new;
$tooltip_tray->set_tip( $tray, GSCROT_NAME . " " . GSCROT_VERSION );

#events and timeouts
$eventbox->signal_connect( 'button_release_event', \&evt_show_icon_menu );

#show tray
$tray->show_all;

#--------------------------------------

#settings
#--------------------------------------
my $profiles_label = Gtk2::Label->new( $d->get( "Profile" ) . " :" );

my $combobox_settings_profiles = Gtk2::ComboBox->new_text;
my @saved_profiles             = glob( "$ENV{'HOME'}/.gscrot/profiles/*.xml" );
my $current_index              = 0;
foreach ( sort @saved_profiles ) {
	utf8::decode $_;
	next
		if $_ =~ /\_accounts.xml/
	;    #accounts file - we are looking for "real" profiles
	$_ =~ /.*\/(.*)\.xml/;    #get profiles name
	my $last_profile_name = $1;
	$combobox_settings_profiles->append_text( $last_profile_name );
	$combobox_settings_profiles->set_active( $current_index )
		if $settings_xml->{ 'general' }->{ 'last_profile_name' } eq
			$last_profile_name;
	$current_index++;
}
my $tooltip_profiles = Gtk2::Tooltips->new;
$tooltip_profiles->set_tip( $combobox_settings_profiles,
							$d->get( "Choose a profile" ) );


my $button_profile_save = Gtk2::Button->new;
$button_profile_save->signal_connect( 'clicked', \&evt_save_profile,
									  $combobox_settings_profiles );
$button_profile_save->set_image(
						  Gtk2::Image->new_from_stock( 'gtk-save', 'button' ) );
my $tooltip_profiles_save = Gtk2::Tooltips->new;
$tooltip_profiles_save->set_tip( $button_profile_save,
								 $d->get( "Save configuration as profile" ) );

my $button_profile_delete = Gtk2::Button->new;
$button_profile_delete->signal_connect( 'clicked', \&evt_delete_profile,
										$combobox_settings_profiles );
$button_profile_delete->set_image(
						Gtk2::Image->new_from_stock( 'gtk-delete', 'button' ) );
my $tooltip_profiles_delete = Gtk2::Tooltips->new;
$tooltip_profiles_delete->set_tip( $button_profile_delete,
								   $d->get( "Delete profile" ) );

my $button_profile_apply = Gtk2::Button->new;
$button_profile_apply->signal_connect( 'clicked', \&evt_apply_profile,
									   $combobox_settings_profiles );
$button_profile_apply->set_image(
						 Gtk2::Image->new_from_stock( 'gtk-apply', 'button' ) );
my $tooltip_profiles_apply = Gtk2::Tooltips->new;
$tooltip_profiles_apply->set_tip(
								  $button_profile_apply,
								  $d->get(
										 "Set profile for current configuration"
								  )
								);


my $file_frame_label = Gtk2::Label->new;
$file_frame_label->set_markup( $d->get( "Image format" ) );
my $file_frame = Gtk2::Frame->new();
$file_frame->set_label_widget( $file_frame_label );
my $save_frame_label = Gtk2::Label->new;
$save_frame_label->set_markup( $d->get( "Save" ) );
my $save_frame = Gtk2::Frame->new();
$save_frame->set_label_widget( $save_frame_label );
my $behavior_frame_label = Gtk2::Label->new;
$behavior_frame_label->set_markup( $d->get( "Behavior" ) );
my $behavior_frame = Gtk2::Frame->new();
$behavior_frame->set_label_widget( $behavior_frame_label );
my $keybinding_frame_label = Gtk2::Label->new;
$keybinding_frame_label->set_markup( $d->get( "Gnome-Keybinding" ) );
my $keybinding_frame = Gtk2::Frame->new();
$keybinding_frame->set_label_widget( $keybinding_frame_label );
my $actions_frame_label = Gtk2::Label->new;
$actions_frame_label->set_markup( $d->get( "Actions" ) );
my $actions_frame = Gtk2::Frame->new();
$actions_frame->set_label_widget( $actions_frame_label );
my $capture_frame_label = Gtk2::Label->new;
$capture_frame_label->set_markup( $d->get( "Capture" ) );
my $capture_frame = Gtk2::Frame->new();
$capture_frame->set_label_widget( $capture_frame_label );

#delay
my $delay_label = Gtk2::Label->new( $d->get( "Delay" ) );
my $delay = Gtk2::HScale->new_with_range( 1, 10, 1 );
$delay->signal_connect( 'value-changed' => \&evt_value_changed,
						'delay_changed' );
$delay->set_value_pos( 'right' );

if ( defined $settings_xml->{ 'general' }->{ 'delay' } ) {
	$delay->set_value( $settings_xml->{ 'general' }->{ 'delay' } );
} else {
	$delay->set_value( 0 );
}
my $delay_active = Gtk2::CheckButton->new;
$delay_active->signal_connect( 'toggled' => \&evt_value_changed,
							   'delay_toggled' );
$delay_active->set_active( TRUE );

if ( defined $settings_xml->{ 'general' }->{ 'delay_active' } ) {
	$delay_active->set_active(
							 $settings_xml->{ 'general' }->{ 'delay_active' } );
} else {
	$delay_active->set_active( FALSE );
}
my $tooltip_delay = Gtk2::Tooltips->new;
$tooltip_delay->set_tip( $delay,
					   $d->get( "Wait n seconds before taking a screenshot" ) );
$tooltip_delay->set_tip( $delay_active,
					   $d->get( "Wait n seconds before taking a screenshot" ) );
$tooltip_delay->set_tip( $delay_label,
					   $d->get( "Wait n seconds before taking a screenshot" ) );
$delay_box->pack_start( $delay_label, FALSE, TRUE, 10 );
$delay_box2->pack_start( $delay_active, FALSE, FALSE, 0 );
$delay_box2->pack_start( $delay,        TRUE,  TRUE,  0 );
$delay_box->pack_start( $delay_box2, TRUE, TRUE, 10 );

#end - delay
#operator
my $combobox_thumb_operator = Gtk2::ComboBox->new_text;
$combobox_thumb_operator->insert_text( 0,
							 "Resize" . " (" . $d->get( "Recommended" ) . ")" );
$combobox_thumb_operator->insert_text( 1, "Thumbnail" );
$combobox_thumb_operator->insert_text( 2, "Sample" );
$combobox_thumb_operator->insert_text( 3, "Scale" );
$combobox_thumb_operator->insert_text( 4, "AdaptiveResize" );

if ( defined $settings_xml->{ 'general' }->{ 'resize_operator' } ) {
	$combobox_thumb_operator->set_active(
						  $settings_xml->{ 'general' }->{ 'resize_operator' } );
} else {
	$combobox_thumb_operator->set_active( 0 );
}
my $tooltip_thumb_operator = Gtk2::Tooltips->new;
$tooltip_thumb_operator->set_tip(
								  $combobox_thumb_operator,
								  $d->get(
									  "Select resize operator\nSee http://www.imagemagick.org/Usage/resize/ for help"
								  )
								);
$resize_operator_box->pack_start( Gtk2::Label->new,         FALSE, FALSE, 0 );
$resize_operator_box->pack_start( $combobox_thumb_operator, TRUE,  TRUE,  10 );

#operator
#thumbnail
my $thumbnail_label = Gtk2::Label->new( $d->get( "Thumbnail" ) );
my $thumbnail = Gtk2::HScale->new_with_range( 1, 100, 1 );
$thumbnail->signal_connect( 'value-changed' => \&evt_value_changed,
							'thumbnail_changed' );
$thumbnail->set_value_pos( 'right' );

if ( defined $settings_xml->{ 'general' }->{ 'thumbnail' } ) {
	$thumbnail->set_value( $settings_xml->{ 'general' }->{ 'thumbnail' } );
} else {
	$thumbnail->set_value( 50 );
}
my $thumbnail_active = Gtk2::CheckButton->new;
$thumbnail_active->signal_connect( 'toggled' => \&evt_value_changed,
								   'thumbnail_toggled' );
$thumbnail_active->set_active( TRUE );

if ( defined $settings_xml->{ 'general' }->{ 'thumbnail_active' } ) {
	$thumbnail_active->set_active(
						 $settings_xml->{ 'general' }->{ 'thumbnail_active' } );
} else {
	$thumbnail_active->set_active( FALSE );
}
my $tooltip_thumb = Gtk2::Tooltips->new;
$tooltip_thumb->set_tip(
						 $thumbnail,
						 $d->get(
							 "Generate thumbnail too.\nselect the percentage of the original size for the thumbnail to be"
						 )
					   );
$tooltip_thumb->set_tip(
						 $thumbnail_active,
						 $d->get(
							 "Generate thumbnail too.\nselect the percentage of the original size for the thumbnail to be"
						 )
					   );
$tooltip_thumb->set_tip(
						 $thumbnail_label,
						 $d->get(
							 "Generate thumbnail too.\nselect the percentage of the original size for the thumbnail to be"
						 )
					   );
$thumbnail_box->pack_start( $thumbnail_label, FALSE, TRUE, 10 );
$thumbnail_box2->pack_start( $thumbnail_active, FALSE, FALSE, 0 );
$thumbnail_box2->pack_start( $thumbnail,        TRUE,  TRUE,  0 );
$thumbnail_box->pack_start( $thumbnail_box2, TRUE, TRUE, 10 );

#end - thumbnail
#filename
my $filename = Gtk2::Entry->new;
if ( defined $settings_xml->{ 'general' }->{ 'filename' } ) {
	$filename->set_text( $settings_xml->{ 'general' }->{ 'filename' } );
} else {
	$filename->set_text( "screenshot_\%NN" );
}
my $filename_label   = Gtk2::Label->new( $d->get( "Filename" ) );
my $tooltip_filename = Gtk2::Tooltips->new;
$tooltip_filename->set_tip(
							$filename,
							$d->get(
								"There are several wild-cards available, like\n%Y = year\n%m = month\n%d = day\n%T = time\n\$w = width\n\$h = height\n%NN = counter"
							)
						  );
$tooltip_filename->set_tip(
							$filename_label,
							$d->get(
								"There are several wild-cards available, like\n%Y = year\n%m = month\n%d = day\n%T = time\n\$w = width\n\$h = height\n%NN = counter"
							)
						  );
$filename_box->pack_start( $filename_label, FALSE, TRUE, 10 );
$filename_box->pack_start( $filename,       TRUE,  TRUE, 10 );

#end - filename
#filetype and scale
my $scale         = Gtk2::HScale->new_with_range( 0, 9, 1 );
my $scale_label   = Gtk2::Label->new( $d->get( "Compression" ) );
my $combobox_type = Gtk2::ComboBox->new_text;
$combobox_type->insert_text( 0, "jpeg" );
$combobox_type->insert_text( 1, "png" );
$combobox_type->signal_connect( 'changed' => \&evt_value_changed,
								'type_changed' );

if ( defined $settings_xml->{ 'general' }->{ 'filetype' } ) {
	$combobox_type->set_active( $settings_xml->{ 'general' }->{ 'filetype' } );
} else {
	$combobox_type->set_active( 1 );
}
my $filetype_label   = Gtk2::Label->new( $d->get( "Image format" ) );
my $tooltip_filetype = Gtk2::Tooltips->new;
$tooltip_filetype->set_tip( $combobox_type, $d->get( "Select a file format" ) );
$tooltip_filetype->set_tip( $filetype_label,
							$d->get( "Select a file format" ) );
$filetype_box->pack_start( $filetype_label, FALSE, TRUE, 10 );
$filetype_box->pack_start( $combobox_type,  TRUE,  TRUE, 10 );
$scale->signal_connect( 'value-changed' => \&evt_value_changed,
						'quality_changed' );
$scale->set_value_pos( 'right' );
$scale->set_value( 1 );

if ( defined $settings_xml->{ 'general' }->{ 'quality' } ) {
	$scale->set_value( $settings_xml->{ 'general' }->{ 'quality' } );
} else {
	$scale->set_value( 9 );
}
my $tooltip_quality = Gtk2::Tooltips->new;
$tooltip_quality->set_tip(
						   $scale,
						   $d->get(
							   "Quality/Compression:\nHigh value means high size / high compression\n(depending on file format chosen)"
						   )
						 );
$tooltip_quality->set_tip(
						   $scale_label,
						   $d->get(
							   "Quality/Compression:\nHigh value means high size / high compression\n(depending on file format chosen)"
						   )
						 );
$scale_box->pack_start( $scale_label, FALSE, TRUE, 10 );
$scale_box->pack_start( $scale,       TRUE,  TRUE, 10 );

#end - filetype and scale
#saveDir
my $saveDir_label = Gtk2::Label->new( $d->get( "Directory" ) );
my $saveDir_button =
	Gtk2::FileChooserButton->new( "GScrot - " . $d->get( "Choose folder" ),
								  'select-folder' );

if ( defined $settings_xml->{ 'general' }->{ 'folder' } ) {
	$saveDir_button->set_current_folder(
								   $settings_xml->{ 'general' }->{ 'folder' } );
}
my $tooltip_saveDir = Gtk2::Tooltips->new;
$tooltip_saveDir->set_tip(
						   $saveDir_button,
						   $d->get(
							   "Your screenshots will be saved\nto this directory"
						   )
						 );
$tooltip_saveDir->set_tip(
						   $saveDir_label,
						   $d->get(
							   "Your screenshots will be saved\nto this directory"
						   )
						 );
$saveDir_box->pack_start( $saveDir_label,  FALSE, TRUE, 10 );
$saveDir_box->pack_start( $saveDir_button, TRUE,  TRUE, 10 );

#end - saveDir
#behavior
my $capture_key = Gtk2::Entry->new;
if ( defined $settings_xml->{ 'general' }->{ 'capture_key' } ) {
	$capture_key->set_text( $settings_xml->{ 'general' }->{ 'capture_key' } );
} else {
	$capture_key->set_text( "Print" );
}
my $capture_label   = Gtk2::Label->new( $d->get( "Capture" ) );
my $tooltip_capture = Gtk2::Tooltips->new;
$tooltip_capture->set_tip(
						   $capture_key,
						   $d->get(
							   "Configure global keybinding for capture\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
						   )
						 );
$tooltip_capture->set_tip(
						   $capture_label,
						   $d->get(
							   "Configure global keybinding for capture\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
						   )
						 );
my $capture_sel_key = Gtk2::Entry->new;

if ( defined $settings_xml->{ 'general' }->{ 'capture_sel_key' } ) {
	$capture_sel_key->set_text(
						  $settings_xml->{ 'general' }->{ 'capture_sel_key' } );
} else {
	$capture_sel_key->set_text( "<Alt>Print" );
}
my $capture_sel_label = Gtk2::Label->new( $d->get( "Capture with selection" ) );
my $tooltip_sel_capture = Gtk2::Tooltips->new;
$tooltip_sel_capture->set_tip(
							   $capture_sel_key,
							   $d->get(
								   "Configure global keybinding for capture with selection\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
							   )
							 );
$tooltip_sel_capture->set_tip(
							   $capture_sel_label,
							   $d->get(
								   "Configure global keybinding for capture with selection\nThe format looks like \"<Control>a\" or \"<Shift><Alt>F1\". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as \"<Ctl>\" and \"<Ctrl>\". If you set the option to the special string \"disabled\", then there will be no keybinding for this action. "
							   )
							 );

#keybindings
my $keybinding_active = Gtk2::CheckButton->new;
$keybinding_active->signal_connect( 'toggled' => \&evt_behavior_handle,
									'keybinding_toggled' );
my $keybinding_sel_active = Gtk2::CheckButton->new;
$keybinding_sel_active->signal_connect( 'toggled' => \&evt_behavior_handle,
										'keybinding_sel_toggled' );
$key_box->pack_start( $capture_label, FALSE, TRUE, 10 );
$key_box2->pack_start( $keybinding_active, FALSE, FALSE, 0 );
$key_box2->pack_start( $capture_key,       TRUE,  TRUE,  0 );
$key_box->pack_start( $key_box2, TRUE, TRUE, 10 );
$key_sel_box->pack_start( $capture_sel_label, FALSE, TRUE, 10 );
$key_sel_box2->pack_start( $keybinding_sel_active, FALSE, FALSE, 0 );
$key_sel_box2->pack_start( $capture_sel_key,       TRUE,  TRUE,  0 );
$key_sel_box->pack_start( $key_sel_box2, TRUE, TRUE, 10 );
$keybinding_active->set_active( TRUE );

if ( defined $settings_xml->{ 'general' }->{ 'keybinding' } ) {
	$keybinding_active->set_active(
							   $settings_xml->{ 'general' }->{ 'keybinding' } );
} else {
	$keybinding_active->set_active( FALSE );
}
$keybinding_sel_active->set_active( TRUE );
if ( defined $settings_xml->{ 'general' }->{ 'keybinding_sel' } ) {
	$keybinding_sel_active->set_active(
						   $settings_xml->{ 'general' }->{ 'keybinding_sel' } );
} else {
	$keybinding_sel_active->set_active( FALSE );
}
my $hide_active = Gtk2::CheckButton->new_with_label(
				 $d->get( "Autohide GScrot Window when taking a screenshot" ) );
my $autocopy_active = Gtk2::CheckButton->new_with_label(
					  $d->get( "Automatically copy screenshot to clipboard" ) );
my $close_at_close_active = Gtk2::CheckButton->new_with_label(
					   $d->get( "Minimize to tray when closing main window" ) );
my $save_at_close_active = Gtk2::CheckButton->new_with_label(
									  $d->get( "Save settings when exiting" ) );

$hide_active->signal_connect( 'toggled' => \&evt_behavior_handle,
							  'hide_toggled' );

if ( defined $settings_xml->{ 'general' }->{ 'autohide' } ) {
	$hide_active->set_active( $settings_xml->{ 'general' }->{ 'autohide' } );
} else {
	$hide_active->set_active( TRUE );
}
my $tooltip_hide = Gtk2::Tooltips->new;
$tooltip_hide->set_tip(
						$hide_active,
						$d->get(
							"Automatically hide GScrot Window when taking a screenshot"
						)
					  );
$autocopy_active->signal_connect( 'toggled' => \&evt_behavior_handle,
								  'autocopy_toggled' );

if ( defined $settings_xml->{ 'general' }->{ 'autocopy' } ) {
	$autocopy_active->set_active(
								 $settings_xml->{ 'general' }->{ 'autocopy' } );
} else {
	$autocopy_active->set_active( TRUE );
}
my $tooltip_autocopy = Gtk2::Tooltips->new;
$tooltip_autocopy->set_tip(
							$autocopy_active,
							$d->get(
									"Automatically copy screenshot to clipboard"
								   )
						  );
$close_at_close_active->signal_connect( 'toggled' => \&evt_behavior_handle,
										'close_at_close_toggled' );

if ( defined $settings_xml->{ 'general' }->{ 'close_at_close' } ) {
	$close_at_close_active->set_active(
						   $settings_xml->{ 'general' }->{ 'close_at_close' } );
} else {
	$close_at_close_active->set_active( TRUE );
}
my $tooltip_close_at_close = Gtk2::Tooltips->new;
$tooltip_close_at_close->set_tip(
								  $close_at_close_active,
								  $d->get(
									  "Minimize to tray when closing main window"
								  )
								);
$save_at_close_active->signal_connect( 'toggled' => \&evt_behavior_handle,
									   'save_at_close_toggled' );

if ( defined $settings_xml->{ 'general' }->{ 'save_at_close' } ) {
	$save_at_close_active->set_active(
							$settings_xml->{ 'general' }->{ 'save_at_close' } );
} else {
	$save_at_close_active->set_active( TRUE );
}
my $tooltip_save_at_close = Gtk2::Tooltips->new;
$tooltip_save_at_close->set_tip(
								 $save_at_close_active,
								 $d->get(
									 "Save settings automatically when exiting GScrot"
								 )
							   );


#end - behavior
#program
my $model =
	Gtk2::ListStore->new( 'Gtk2::Gdk::Pixbuf', 'Glib::String', 'Glib::String' );
foreach ( keys %gm_programs ) {

	if (    $gm_programs{ $_ }->{ 'binary' } ne ""
		 && $gm_programs{ $_ }->{ 'name' } ne "" )
	{
		my $pixbuf;
		if ( -f $gm_programs{ $_ }->{ 'pixmap' } ) {
			$pixbuf =
				Gtk2::Gdk::Pixbuf->new_from_file_at_size(
											 $gm_programs{ $_ }->{ 'pixmap' },
											 Gtk2::IconSize->lookup( 'menu' ) );
		} else {
			$pixbuf =
				Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/executable.svg",
					 Gtk2::IconSize->lookup( 'menu' ) );
		}
		$model->set( $model->append, 0, $pixbuf, 1,
					 $gm_programs{ $_ }->{ 'name' },
					 2, $_ );
	} else {
		print "WARNING: Program $_ is not configured properly, ignoring\n";
	}
}
my $progname     = Gtk2::ComboBox->new( $model );
my $renderer_pix = Gtk2::CellRendererPixbuf->new;
$progname->pack_start( $renderer_pix, FALSE );
$progname->add_attribute( $renderer_pix, pixbuf => 0 );
my $renderer_text = Gtk2::CellRendererText->new;
$progname->pack_start( $renderer_text, FALSE );
$progname->add_attribute( $renderer_text, text => 1 );

if ( defined $settings_xml->{ 'general' }->{ 'prog' } ) {
	$model->foreach( \&fct_iter_programs,
					 $settings_xml->{ 'general' }->{ 'prog' } );
} else {
	$progname->set_active( FALSE );
}
my $progname_active = Gtk2::CheckButton->new;
$progname_active->signal_connect( 'toggled' => \&evt_value_changed,
								  'progname_toggled' );
if ( defined $settings_xml->{ 'general' }->{ 'prog_active' } ) {
	$progname_active->set_active(
							  $settings_xml->{ 'general' }->{ 'prog_active' } );
} else {
	$progname_active->set_active( TRUE );
}
my $progname_label   = Gtk2::Label->new( $d->get( "Open with" ) );
my $tooltip_progname = Gtk2::Tooltips->new;
$tooltip_progname->set_tip(
							$progname,
							$d->get(
								"Open your screenshot\nwith this program after capturing"
							)
						  );
$tooltip_progname->set_tip(
							$progname_active,
							$d->get(
								"Open your screenshot\nwith this program after capturing"
							)
						  );
$tooltip_progname->set_tip(
							$progname_label,
							$d->get(
								"Open your screenshot\nwith this program after capturing"
							)
						  );
$progname_box->pack_start( $progname_label, TRUE, TRUE, 10 );
$progname_box2->pack_start( $progname_active, FALSE, TRUE, 0 );
$progname_box2->pack_start( $progname,        TRUE,  TRUE, 0 );
$progname_box->pack_start( $progname_box2, TRUE, TRUE, 10 );

#end - program
#im_colors
my $combobox_im_colors = Gtk2::ComboBox->new_text;
$combobox_im_colors->insert_text( 0, $d->get( "16 colors   - (4bit) " ) );
$combobox_im_colors->insert_text( 1, $d->get( "64 colors   - (6bit) " ) );
$combobox_im_colors->insert_text( 2, $d->get( "256 colors  - (8bit) " ) );
$combobox_im_colors->signal_connect( 'changed' => \&evt_value_changed,
									 'border_changed' );

if ( defined $settings_xml->{ 'general' }->{ 'im_colors' } ) {
	$combobox_im_colors->set_active(
								$settings_xml->{ 'general' }->{ 'im_colors' } );
} else {
	$combobox_im_colors->set_active( 2 );
}
my $im_colors_active = Gtk2::CheckButton->new;
$im_colors_active->signal_connect( 'toggled' => \&evt_value_changed,
								   'im_colors_toggled' );
$im_colors_active->set_active( TRUE );

if ( defined $settings_xml->{ 'general' }->{ 'im_colors_active' } ) {
	$im_colors_active->set_active(
						 $settings_xml->{ 'general' }->{ 'im_colors_active' } );
} else {
	$im_colors_active->set_active( FALSE );
}
my $im_colors_label   = Gtk2::Label->new( $d->get( "Reduce colors" ) );
my $tooltip_im_colors = Gtk2::Tooltips->new;
$tooltip_im_colors->set_tip(
							 $combobox_im_colors,
							 $d->get(
								 "Automatically reduce colors \nafter taking a screenshot"
							 )
						   );
$tooltip_im_colors->set_tip(
							 $im_colors_active,
							 $d->get(
								 "Automatically reduce colors \nafter taking a screenshot"
							 )
						   );
$tooltip_im_colors->set_tip(
							 $im_colors_label,
							 $d->get(
								 "Automatically reduce colors \nafter taking a screenshot"
							 )
						   );
$im_colors_box->pack_start( $im_colors_label, TRUE, TRUE, 10 );
$im_colors_box2->pack_start( $im_colors_active,   FALSE, TRUE, 0 );
$im_colors_box2->pack_start( $combobox_im_colors, TRUE,  TRUE, 0 );
$im_colors_box->pack_start( $im_colors_box2, TRUE, TRUE, 10 );

#end - colors
#border
my $combobox_border = Gtk2::ComboBox->new_text;
$combobox_border->insert_text( 1, $d->get( "activate" ) );
$combobox_border->insert_text( 0, $d->get( "deactivate" ) );
$combobox_border->signal_connect( 'changed' => \&evt_value_changed,
								  'border_changed' );

if ( defined $settings_xml->{ 'general' }->{ 'border' } ) {
	$combobox_border->set_active( $settings_xml->{ 'general' }->{ 'border' } );
} else {
	$combobox_border->set_active( TRUE );
}
my $border_label   = Gtk2::Label->new( $d->get( "Window border" ) );
my $tooltip_border = Gtk2::Tooltips->new;
$tooltip_border->set_tip(
						  $combobox_border,
						  $d->get(
								   "Include wm border when selecting a window"
								 )
						);
$tooltip_border->set_tip(
						  $border_label,
						  $d->get(
								   "Include wm border when selecting a window"
								 )
						);
$border_box->pack_start( $border_label,    FALSE, TRUE, 10 );
$border_box->pack_start( $combobox_border, TRUE,  TRUE, 10 );

#end - border

#cursor
my $combobox_cursor = Gtk2::ComboBox->new_text;
$combobox_cursor->insert_text( 1, $d->get( "activate" ) );
$combobox_cursor->insert_text( 0, $d->get( "deactivate" ) );
$combobox_cursor->signal_connect( 'changed' => \&evt_value_changed,
								  'cursor_changed' );

if ( defined $settings_xml->{ 'general' }->{ 'cursor' } ) {
	$combobox_cursor->set_active( $settings_xml->{ 'general' }->{ 'cursor' } );
} else {
	$combobox_cursor->set_active( TRUE );
}
my $cursor_label   = Gtk2::Label->new( $d->get( "Include cursor" ) );
my $tooltip_cursor = Gtk2::Tooltips->new;
$tooltip_cursor->set_tip( $combobox_cursor,
						 $d->get( "Include cursor when taking a screenshot" ) );
$tooltip_cursor->set_tip( $cursor_label,
						 $d->get( "Include cursor when taking a screenshot" ) );
$cursor_box->pack_start( $cursor_label,    FALSE, TRUE, 10 );
$cursor_box->pack_start( $combobox_cursor, TRUE,  TRUE, 10 );

#end - cursor


#accounts
#--------------------------------------
my $accounts_model = undef;
&fct_load_accounts_tree;

my $accounts_tree = Gtk2::TreeView->new_with_model( $accounts_model );
$accounts_tree->signal_connect( 'row-activated' => \&evt_accounts,
								'row_activated' );

&fct_set_model_accounts( $accounts_tree );

my $accounts_label = Gtk2::Label->new;
$accounts_label->set_line_wrap( TRUE );
$accounts_label->set_markup(
	$d->get(
		"<b>Note:</b> Entering your Accounts for specific hosting-sites is optional. If entered it will give you the same benefits as the upload on the website. If you leave these fields empty you will be able to upload to the specific hosting-partner as a guest."
	)
);

#--------------------------------------

#plugins
#--------------------------------------
my $effects_model = undef;
&fct_load_plugin_tree;

my $effects_tree = Gtk2::TreeView->new_with_model( $effects_model );
$effects_tree->signal_connect( 'row-activated' => \&evt_plugins,
							   'row_activated' );

&fct_set_model_plugins( $effects_tree );

#--------------------------------------

#packing
#--------------------------------------
$file_vbox->pack_start( $scale_box,    TRUE,  TRUE, 5 );
$file_vbox->pack_start( $filetype_box, FALSE, TRUE, 5 );
$file_frame->add( $file_vbox );

$save_vbox->pack_start( $filename_box, TRUE,  TRUE, 5 );
$save_vbox->pack_start( $saveDir_box,  FALSE, TRUE, 5 );
$save_frame->add( $save_vbox );

$vbox_basic->pack_start( $file_frame, FALSE, TRUE, 5 );
$vbox_basic->pack_start( $save_frame, FALSE, TRUE, 5 );
$vbox_basic->set_border_width( 5 );

$behavior_vbox->pack_start( $autocopy_active,       TRUE, TRUE, 5 );
$behavior_vbox->pack_start( $hide_active,           TRUE, TRUE, 5 );
$behavior_vbox->pack_start( $close_at_close_active, TRUE, TRUE, 5 );
$behavior_vbox->pack_start( $save_at_close_active,  TRUE, TRUE, 5 );
$behavior_frame->add( $behavior_vbox );

$keybinding_vbox->pack_start( $key_box,     TRUE, TRUE, 5 );
$keybinding_vbox->pack_start( $key_sel_box, TRUE, TRUE, 5 );
$keybinding_frame->add( $keybinding_vbox );

$vbox_behavior->pack_start( $behavior_frame,   TRUE, TRUE, 0 );
$vbox_behavior->pack_start( $keybinding_frame, TRUE, TRUE, 0 );
$vbox_behavior->set_border_width( 5 );

$capture_vbox->pack_start( $delay_box,  TRUE, TRUE, 5 );
$capture_vbox->pack_start( $border_box, TRUE, TRUE, 5 );
$capture_vbox->pack_start( $cursor_box, TRUE, TRUE, 5 );
$capture_frame->add( $capture_vbox );

$actions_vbox->pack_start( $progname_box,        TRUE, TRUE, 5 );
$actions_vbox->pack_start( $im_colors_box,       TRUE, TRUE, 5 );
$actions_vbox->pack_start( $thumbnail_box,       TRUE, TRUE, 5 );
$actions_vbox->pack_start( $resize_operator_box, TRUE, TRUE, 5 );

$actions_frame->add( $actions_vbox );
my $label_basic = Gtk2::Label->new;
$label_basic->set_markup( $d->get( "<i>Main</i>" ) );
my $label_extras = Gtk2::Label->new;
$label_extras->set_markup( $d->get( "<i>Advanced</i>" ) );
my $label_behavior = Gtk2::Label->new;
$label_behavior->set_markup( $d->get( "<i>Behavior</i>" ) );

my $notebook_settings_first =
	$notebook_settings->append_page( $vbox_basic, $label_basic );
my $notebook_settings_second =
	$notebook_settings->append_page( $vbox_extras, $label_extras );
my $notebook_settings_third =
	$notebook_settings->append_page( $vbox_behavior, $label_behavior );

$vbox_extras->pack_start( $actions_frame, TRUE, TRUE, 1 );
$vbox_extras->pack_start( $capture_frame, TRUE, TRUE, 1 );
$vbox_extras->set_border_width( 5 );

my $scrolled_accounts_window = Gtk2::ScrolledWindow->new;
$scrolled_accounts_window->set_policy( 'automatic', 'automatic' );
$scrolled_accounts_window->add( $accounts_tree );

my $label_accounts = Gtk2::Label->new;
$label_accounts->set_markup( $d->get( "<i>Accounts</i>" ) );
$accounts_vbox->pack_start( $scrolled_accounts_window, TRUE, TRUE, 1 );
$accounts_vbox->pack_start( $accounts_label,           TRUE, TRUE, 1 );
$vbox_accounts->pack_start( $accounts_vbox,            TRUE, TRUE, 1 );
$vbox_accounts->set_border_width( 5 );

my $notebook_settings_fourth =
	$notebook_settings->append_page( $vbox_accounts, $label_accounts );

if ( keys( %plugins ) > 0 ) {
	my $scrolled_plugins_window = Gtk2::ScrolledWindow->new;
	$scrolled_plugins_window->set_policy( 'automatic', 'automatic' );
	$scrolled_plugins_window->add( $effects_tree );
	my $label_plugins = Gtk2::Label->new;
	$label_plugins->set_markup( $d->get( "<i>Plugins</i>" ) );
	$effects_vbox->pack_start( $scrolled_plugins_window, TRUE, TRUE, 1 );
	$vbox_plugins->pack_start( $effects_vbox,            TRUE, TRUE, 1 );
	$vbox_plugins->set_border_width( 5 );
	my $notebook_settings_fifth =
		$notebook_settings->append_page( $vbox_plugins, $label_plugins );
}
$profiles_box->pack_start( $profiles_label,             FALSE, TRUE, 1 );
$profiles_box->pack_start( $combobox_settings_profiles, TRUE,  TRUE, 1 );
$profiles_box->pack_start( $button_profile_save,        FALSE, TRUE, 1 );
$profiles_box->pack_start( $button_profile_delete,      FALSE, TRUE, 1 );
$profiles_box->pack_start( $button_profile_apply,       FALSE, TRUE, 1 );

$vbox_settings->pack_start( $profiles_box,      TRUE, TRUE, 1 );
$vbox_settings->pack_start( $notebook_settings, TRUE, TRUE, 1 );

#settings
$settings_dialog->vbox->add( $vbox_settings );
$settings_dialog->set_default_response( 'apply' );


#main app
$vbox->pack_start( $notebook,  TRUE,  TRUE,  0 );
$vbox->pack_start( $statusbar, FALSE, FALSE, 0 );

#--------------------------------------

unless ( $min_cparam ) {
	$window->show_all;
} else {
	$window->hide;
}

#load saved settings
my $folder_to_save = $settings_xml->{ 'general' }->{ 'folder' }
	|| $ENV{ 'HOME' };
if ( $start_with && $folder_to_save ) {
	if ( $start_with eq "raw" ) {
		&evt_take_screenshot( 'global_keybinding', "raw", $folder_to_save );
	} elsif ( $start_with eq "select" ) {
		&evt_take_screenshot( 'global_keybinding', "select", $folder_to_save );
	} elsif ( $start_with eq "window" ) {
		&evt_take_screenshot( 'global_keybinding', "window", $folder_to_save );
	} elsif ( $start_with eq "section" ) {
		&evt_take_screenshot( 'global_keybinding', "section", $folder_to_save );
	}
}

Gtk2->main;
0;

#events
#--------------------------------------
sub evt_navigate {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;
	if ( $data eq "first" ) {
		$notebook->set_current_page( 0 );
	} elsif ( $data eq "last" ) {
		$notebook->set_current_page( $notebook->get_n_pages - 1 );
	} elsif ( $data eq "previous" ) {
		$notebook->prev_page;
	} elsif ( $data eq "forward" ) {
		$notebook->next_page;
	}
	return 1;
}

sub evt_value_changed {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	#checkbox for "open with" -> entry active/inactive
	if ( $data eq "progname_toggled" ) {
		if ( $progname_active->get_active ) {
			$progname->set_sensitive( TRUE );
		} else {
			$progname->set_sensitive( FALSE );
		}
	}

	#checkbox for "color depth" -> entry active/inactive
	if ( $data eq "im_colors_toggled" ) {
		if ( $im_colors_active->get_active ) {
			$combobox_im_colors->set_sensitive( TRUE );
		} else {
			$combobox_im_colors->set_sensitive( FALSE );
		}
	}

	#checkbox for "delay" -> HScale active/inactive
	if ( $data eq "delay_toggled" ) {
		if ( $delay_active->get_active ) {
			$delay->set_sensitive( TRUE );
		} else {
			$delay->set_sensitive( FALSE );
		}
	}

	#checkbox for "thumbnail" -> HScale active/inactive
	if ( $data eq "thumbnail_toggled" ) {
		if ( $thumbnail_active->get_active ) {
			$thumbnail->set_sensitive( TRUE );
			$combobox_thumb_operator->set_sensitive( TRUE );
		} else {
			$thumbnail->set_sensitive( FALSE );
			$combobox_thumb_operator->set_sensitive( FALSE );
		}
	}

	#filetype changed
	if ( $data eq "type_changed" ) {
		if ( $combobox_type->get_active_text eq "jpeg" ) {
			$scale->set_range( 1, 100 );
			$scale->set_value( 75 );
			$scale_label->set_text( $d->get( "Quality" ) );
		} elsif ( $combobox_type->get_active_text eq "png" ) {
			$scale->set_range( 0, 9 );
			$scale->set_value( 9 );
			$scale_label->set_text( $d->get( "Compression" ) );
		}
	}
}

sub evt_take_screenshot {
	my ( $widget, $data, $folder_from_config ) = @_;
	my $quality_value             = undef;
	my $delay_value               = undef;
	my $thumbnail_value           = undef;
	my $progname_value            = undef;
	my $im_colors_value           = undef;
	my $filename_value            = undef;
	my $filetype_value            = undef;
	my $folder                    = undef;
	my $screenshot                = undef;
	my $screenshot_name           = undef;
	my $screenshot_thumbnail      = undef;
	my $screenshot_thumbnail_name = undef;
	my $thumbnail_ending          = "thumb";
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;
	&fct_set_toolbar_sensitive( FALSE );

	#determine current file type
	$filetype_value = $combobox_type->get_active_text;

	#determine folder to save
	$folder = $saveDir_button->get_filename || $folder_from_config;
	utf8::decode $folder;

	if ( $filetype_value eq "jpeg" ) {
		$quality_value = $scale->get_value();
	} elsif ( $filetype_value eq "png" ) {
		$quality_value = $scale->get_value * 10 + 5;
	}
	if ( $delay_active->get_active ) {
		$delay_value = $delay->get_value;
	} else {
		$delay_value = 0;
	}
	if ( $thumbnail_active->get_active ) {
		$thumbnail_value = $thumbnail->get_value;
	}

	#prepare filename, parse wild-cards
	$filename_value = $filename->get_text();
	utf8::decode $filename_value;
	$filename_value = strftime $filename_value , localtime;
	$filename_value =
		&fct_get_next_filename( $filename_value, $folder, $filetype_value );

	#hide mainwindow
	if (    $hide_active->get_active
		 && ( $data ne "web" && $data ne "tray_web" )
		 && !$is_in_tray )
	{
		$window->hide;
		Gtk2::Gdk->flush;
		$is_in_tray = TRUE;
		sleep 1;
	}

	#fullscreen screenshot
	if ( $data eq "raw" || $data eq "tray_raw" ) {
		$active_workspace = $screen->get_active_workspace;
		unless (    $filename_value =~ /[a-zA-Z0-9]+/
				 && defined( $folder )
				 && defined( $filetype_value ) )
		{
			&dlg_error_message( $d->get( "No valid filename specified" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}
		$screenshot =
			&fct_gscrot_workspace(
								   $folder,
								   $filename_value,
								   $filetype_value,
								   $quality_value,
								   $delay_value,
								   $combobox_border->get_active,
								   $combobox_cursor->get_active,
								   $active_workspace->get_number
								 );

		#window
	} elsif (    $data eq "window"
			  || $data eq "tray_window"
			  || $data eq "section"
			  || $data eq "tray_section" )
	{
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message( $d->get( "No valid filename specified" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}
		$screenshot =
			&fct_gscrot_window(
								$folder,
								$filename_value,
								$filetype_value,
								$quality_value,
								$delay_value,
								$combobox_border->get_active,
								$combobox_cursor->get_active,
								$data
							  );

		#selection
	} elsif ( $data eq "select" || $data eq "tray_select" ) {
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message( $d->get( "No valid filename specified" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}
		$screenshot = &fct_gscrot_area(
										$folder,
										$filename_value,
										$filetype_value,
										$quality_value,
										$delay_value,
										$combobox_cursor->get_active
									  );

		#web
	} elsif ( $data eq "web" || $data eq "tray_web" ) {
		my $url = &dlg_website;
		unless ( $url ) { &fct_set_toolbar_sensitive( TRUE ); return 0 }
		my $hostname = $url;
		$hostname =~ s/http:\/\///;

		if ( $hostname eq "" ) {
			&dlg_error_message( $d->get( "No valid url entered" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}

		#delay doesnt make much sense here, but it's implemented ;-)
		if ( $delay_active->get_active ) {
			sleep $delay_value;
		}

		#determining timeout
		my $web_menu = $button_web_menu->get_menu;
		my @timeouts = $web_menu->get_children;
		my $timeout  = undef;
		foreach ( @timeouts ) {

			if ( $_->get_active ) {
				$timeout = $_->get_children->get_text;
				$timeout =~ /([0-9]+)/;
				$timeout = $1;
				print $timeout. "\n" if $debug_cparam;
			}
		}

		#check if file already exists
		if ( &fct_file_exists( "$folder/$filename_value.$filetype_value" ) ) {
			unless (
					&dlg_question_message(
						$d->get(
							"File already exists.\nDo you want to overwrite it?"
						)
					)
				   )
			{
				$screenshot = 5;
			} else {

				print "Starting webshot ...\n" if $debug_cparam;
				$screenshot =
					`gnome-web-photo --timeout=$timeout --mode=photo --format=$filetype_value -q $quality_value '$url' '$folder/$filename_value.$filetype_value'`;
				print "... webshot finished!\n" if $debug_cparam;

			}
		} else {

			print "Starting webshot ...\n" if $debug_cparam;
			$screenshot =
				`gnome-web-photo --timeout=$timeout --mode=photo --format=$filetype_value -q $quality_value '$url' '$folder/$filename_value.$filetype_value'`;
			print "... webshot finished!\n" if $debug_cparam;

		}

		my $width  = 0;
		my $height = 0;

		if ( $screenshot eq "" ) {
			$screenshot_name = "$folder/$filename_value.$filetype_value";
			$screenshot =
				&fct_imagemagick_perform( "get_object", $screenshot_name, 0,
										  $filetype_value );
		} elsif ( $screenshot == 5 ) {
			&dlg_status_message( 1, $d->get( "Capture aborted by user" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;

		} else {
			&dlg_error_message(
				   $d->get( "Unable to capture website" ) . " \n" . $hostname );
			&dlg_status_message( 1,
					 $d->get( "Unable to capture website" ) . " " . $hostname );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}
	} elsif ( $data =~ /^gscrot_window_direct(.*)/ ) {
		my $xid = $1;
		print "Selected xid: $xid\n" if $debug_cparam;
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message( $d->get( "No valid filename specified" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}
		$screenshot =
			&fct_gscrot_window_direct(
									   $folder,
									   $filename_value,
									   $filetype_value,
									   $quality_value,
									   $delay_value,
									   $combobox_border->get_active,
									   $combobox_cursor->get_active,
									   $xid
									 );
	} elsif ( $data =~ /^gscrot_wrksp_direct(.*)/ ) {
		my $selected_workspace = $1;
		print "Selected workspace: $selected_workspace\n" if $debug_cparam;
		unless ( $filename_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message( $d->get( "No valid filename specified" ) );
			&fct_set_toolbar_sensitive( TRUE );
			return FALSE;
		}
		$screenshot =
			&fct_gscrot_workspace(
								   $folder,
								   $filename_value,
								   $filetype_value,
								   $quality_value,
								   $delay_value,
								   $combobox_border->get_active,
								   $combobox_cursor->get_active,
								   $selected_workspace
								 );
	}
	if ( $hide_active->get_active && ( $data ne "web" && $data ne "tray_web" ) )
	{
		$window->show_all;
		Gtk2::Gdk->flush;
		$is_in_tray = FALSE;
	}

	#screenshot was taken at this stage...
	#start postprocessing here

	#check if file already exists
	if ( &fct_file_exists( "$folder/$filename_value.$filetype_value" )
		 && ( $data ne "web" && $data ne "tray_web" ) )
	{
		unless (
			 &dlg_question_message(
				 $d->get( "File already exists.\nDo you want to overwrite it?" )
			 )
			)
		{
			$screenshot = 5;
		}
	}

	#user aborted screenshot
	if ( $screenshot == 5 ) {
		&dlg_status_message( 1, $d->get( "Capture aborted by user" ) );
		&fct_set_toolbar_sensitive( TRUE );
		return FALSE;
	}

	#...successfully???
	unless ( $screenshot ) {
		&dlg_error_message(
			$d->get(
				"Screenshot failed!\nMaybe mouse pointer could not be grabbed or the selected area is invalid."
			)
		);
		print "Screenshot failed!" if $debug_cparam;
		&dlg_status_message( 1, $d->get( "Screenshot failed!" ) );
		&fct_set_toolbar_sensitive( TRUE );
		return FALSE;
	} else {

		#quantize
		if ( $im_colors_active->get_active ) {
			$im_colors_value = $combobox_im_colors->get_active_text();
			$im_colors_value =~ /.*\(([0-9]*).*\)/;
			$screenshot->Quantize( colors => 2**$1 );
		}

		#generate the thumbnail
		if ( $thumbnail_active->get_active ) {

			#copy orig image object
			$screenshot_thumbnail = $screenshot->copy;

			#calculate size
			my $twidth =
				int( $screenshot_thumbnail->Get( 'columns' ) *
					 ( $thumbnail_value / 100 ) );
			my $theight =
				int( $screenshot_thumbnail->Get( 'rows' ) *
					 ( $thumbnail_value / 100 ) );

			#resize it
			&fct_resize_imagemagick_object( \$screenshot_thumbnail, $twidth,
											$theight );

			#save path of thumbnail
			$screenshot_thumbnail_name =
				"$folder/$filename_value-$thumbnail_ending.$filetype_value";

			#parse wild cards
			$screenshot_thumbnail_name =~ s/\$w/$twidth/g;
			$screenshot_thumbnail_name =~ s/\$h/$theight/g;
			print "Trying to save file to $screenshot_thumbnail_name\n"
				if $debug_cparam;

			#finally save it to disk
			$screenshot_thumbnail->Write(filename => $screenshot_thumbnail_name,
										 quality  => $quality_value );
			unless ( &fct_file_exists( $screenshot_thumbnail_name ) ) {
				&dlg_error_message(
								   $d - get( "Could not generate thumbnail" ) );
				undef $screenshot_thumbnail;
				&fct_set_toolbar_sensitive( TRUE );
				return 0;
			}
		}

		#and save the filename
		$screenshot_name = "$folder/$filename_value.$filetype_value";
		my $swidth  = $screenshot->Get( 'columns' );
		my $sheight = $screenshot->Get( 'rows' );

		#parse wild cards
		$screenshot_name =~ s/\$w/$swidth/g;
		$screenshot_name =~ s/\$h/$sheight/g;
		print "Trying to save file to $screenshot_name\n" if $debug_cparam;

		#save orig file to disk
		$screenshot->Write( filename => $screenshot_name,
							quality  => $quality_value );
	}    #end screenshot successfull
	if ( &fct_file_exists( $screenshot_name ) ) {

		#integrate it into the notebook
		my $new_key_screenshot =
			&fct_integrate_screenshot_in_notebook( $screenshot_name );

		#thumbnail as well if present
		my $new_key_screenshot_thumbnail =
			&fct_integrate_screenshot_in_notebook( $screenshot_thumbnail_name )
			if $thumbnail_active->get_active;

		#autocopy to clipboard if configured
		if ( $autocopy_active->get_active() ) {
			my $pixbuf = Gtk2::Gdk::Pixbuf->new_from_file(
						  $session_screens{ $new_key_screenshot }->{ 'long' } );
			$clipboard->set_image( $pixbuf );
		}

		#open screenshot with configured program
		if ( $progname_active->get_active ) {
			my $model         = $progname->get_model();
			my $progname_iter = $progname->get_active_iter();
			if ( $progname_iter ) {
				$progname_value = $model->get_value( $progname_iter, 2 );
				utf8::decode $progname_value;
				unless ( $progname_value =~ /[a-zA-Z0-9]+/ ) {
					&dlg_error_message(
						   $d->get(
							   "No application specified to open the screenshot"
						   )
					);
					&fct_set_toolbar_sensitive( TRUE );
					return FALSE;
				}
				system(
					"$progname_value '$session_screens{$new_key_screenshot}->{'long'}' &"
				);    #open picture in external program
			}
		}
		print "screenshot successfully saved to $screenshot_name!\n"
			if $debug_cparam;
		&dlg_status_message(
							 1,
							 "$session_screens{$new_key_screenshot}->{'short'} "
								 . $d->get( "saved" )
						   );
	} else {
		&dlg_error_message(
			$d->get(
				"Screenshot failed!\nMaybe mouse pointer could not be grabbed or the selected area is invalid."
			)
		);
		print "Screenshot failed!" if $debug_cparam;
		&dlg_status_message( 1, $d->get( "Screenshot failed!" ) );
	}

	#destroy the imagemagick objects and free memory
	undef $screenshot;
	undef $screenshot_thumbnail;
	&fct_set_toolbar_sensitive( TRUE );

	#focus window after taking a screenshot
	$window->window->focus( time );
	return 1;
}

sub evt_behavior_handle {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	#checkbox for "keybinding" -> entry active/inactive
	if ( $data eq "keybinding_toggled" ) {
		if ( $keybinding_active->get_active ) {
			$capture_key->set_sensitive( TRUE );
		} else {
			$capture_key->set_sensitive( FALSE );
		}
		&fct_save_bindings();
	}

	#checkbox for "keybinding_sel" -> entry active/inactive
	if ( $data eq "keybinding_sel_toggled" ) {
		if ( $keybinding_sel_active->get_active ) {
			$capture_sel_key->set_sensitive( TRUE );
		} else {
			$capture_sel_key->set_sensitive( FALSE );
		}
		&fct_save_bindings();
	}
	return 1;
}

sub evt_notebook_switch {
	my ( $widget, $pointer, $int ) = @_;
	if ( $menuitem_save_as && $menuitem_close && $menuitem_close_all ) {
		if ( $int == 0 ) {
			$menuitem_save_as->set_sensitive( FALSE );
			$menuitem_close->set_sensitive( FALSE );
		} else {
			$menuitem_save_as->set_sensitive( TRUE );
			$menuitem_close->set_sensitive( TRUE );
		}
	}

	&fct_update_first_tab();    #update first tab for information
}

sub evt_delete_window {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	if ( $data ne "menu_quit" && $close_at_close_active->get_active ) {
		$window->hide;
		$is_in_tray = TRUE;
		return TRUE;
	}

	if ( $save_at_close_active->get_active ) {
		&fct_save_settings( undef );
		&fct_save_settings( $combobox_settings_profiles->get_active_text )
			if $combobox_settings_profiles->get_active != -1;
	}

	Gtk2->main_quit;
	return FALSE;
}

sub evt_bug {
	&fct_gnome_open( undef, "https://bugs.launchpad.net/gscrot", undef );
}

sub evt_question {
	&fct_gnome_open( undef, "https://answers.launchpad.net/gscrot", undef );
}

sub evt_translate {
	&fct_gnome_open( undef, "https://translations.launchpad.net/gscrot",
					 undef );
}

sub evt_about {
	my ( $widget, $data ) = @_;
	if ( $debug_cparam ) {
		print "\n$data was emitted by widget $widget\n";
	}
	open( GPL_HINT, "$gscrot_root/share/gscrot/resources/license/gplv3_hint" )
		or die "ERROR--> Failed to open copyright-file!";
	my @copyright_hint = <GPL_HINT>;
	close( GPL_HINT );
	open( GPL, "$gscrot_root/share/gscrot/resources/license/gplv3" )
		or die "ERROR--> Failed to open license-file!";
	my @copyright = <GPL>;
	close( GPL );
	open( GPL, "$gscrot_root/share/gscrot/resources/pofiles/credits" )
		or die "ERROR--> Failed to open credits-file!";
	my @translators = <GPL>;
	close( GPL );
	my $all_lines = "";

	foreach my $line ( @copyright ) {
		utf8::decode $line;
		$all_lines = $all_lines . $line;
	}
	my $all_hints = "";
	foreach my $hint ( @copyright_hint ) {
		utf8::decode $hint;
		$all_hints = $all_hints . $hint;
	}
	my $all_translators = "";
	foreach my $translator ( @translators ) {
		utf8::decode $translator;
		$all_translators = $all_translators . $translator;
	}
	my $website = "http://launchpad.net/gscrot";
	my $about   = Gtk2::AboutDialog->new;
	my $logo =
		Gtk2::Gdk::Pixbuf->new_from_file_at_size(
										"$gscrot_root/share/pixmaps/gscrot.svg",
										150, 150 );
	$about->set_logo( $logo );
	$about->set_name( GSCROT_NAME ) unless Gtk2->CHECK_VERSION( 2, 12, 0 );
	$about->set_program_name( GSCROT_NAME ) if Gtk2->CHECK_VERSION( 2, 12, 0 );
	$about->set_version( GSCROT_VERSION );
	$about->set_url_hook( \&fct_gnome_open );
	$about->set_website_label( $website );
	$about->set_website( $website );
	$about->set_email_hook( \&fct_gnome_open_mail );
	$about->set_authors(
		"Development:\nMario Kemper <mario.kemper\@googlemail.com>\nRene Hennig <Rene.Hennig\@my-united.net>\n\nPlugins:\nMartin Rabeneck (cornix) <martinrabeneck\@gmx.net>\n\nubuntu-pics.de:\nRene Hennig <Rene.Hennig\@my-united.net>"
	);
	$about->set_artists( "Pascal Grochol <pg0803\@gmail.com>",
						 "Arne Weinberg" );
	$about->set_translator_credits( $all_translators );
	$about->set_copyright( $all_hints );
	$about->set_license( $all_lines );
	$about->set_comments( GSCROT_VERSION_FULL );
	$about->show_all;
	$about->signal_connect( 'response' => sub { $about->destroy } );
}

sub evt_show_icon_menu {
	my ( $widget, $data ) = @_;
	if ( $debug_cparam ) {
		print "\n$data was emitted by widget $widget\n";
	}

	#left button (mouse)
	if ( $_[ 1 ]->button == 1 ) {
		if ( $window->visible ) {
			$window->hide;
			$is_in_tray = TRUE;
		} else {
			$window->show_all;
			$is_in_tray = FALSE;
		}
	}

	#right button (mouse)
	elsif ( $_[ 1 ]->button == 3 ) {
		my $tray_menu = Gtk2::Menu->new();
		my $menuitem_select =
			Gtk2::ImageMenuItem->new( $d->get( "Selection" ) );
		$menuitem_select->set_image(
			  Gtk2::Image->new_from_pixbuf(
				  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					  "$gscrot_root/share/gscrot/resources/icons/selection.svg",
					  Gtk2::IconSize->lookup( 'menu' )
				  )
			  )
		);
		$menuitem_select->signal_connect( activate => \&evt_take_screenshot,
										  'tray_select' );
		my $menuitem_raw = Gtk2::ImageMenuItem->new( $d->get( "Fullscreen" ) );
		$menuitem_raw->set_image(
			 Gtk2::Image->new_from_pixbuf(
				 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/fullscreen.svg",
					 Gtk2::IconSize->lookup( 'menu' )
				 )
			 )
		);
		$menuitem_raw->signal_connect( activate => \&evt_take_screenshot,
									   'tray_raw' );
		my $menuitem_window = Gtk2::ImageMenuItem->new( $d->get( "Window" ) );
		$menuitem_window->set_image(
			 Gtk2::Image->new_from_pixbuf(
				 Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/sel_window.svg",
					 Gtk2::IconSize->lookup( 'menu' )
				 )
			 )
		);
		$menuitem_window->signal_connect( activate => \&evt_take_screenshot,
										  'tray_window' );
		my $menuitem_window_sect =
			Gtk2::ImageMenuItem->new( $d->get( "Section" ) );
		$menuitem_window_sect->set_image(
			Gtk2::Image->new_from_pixbuf(
				Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					"$gscrot_root/share/gscrot/resources/icons/sel_window_section.svg",
					Gtk2::IconSize->lookup( 'menu' )
				)
			)
		);
		$menuitem_window_sect->signal_connect(activate => \&evt_take_screenshot,
											  'tray_section' );
		my $menuitem_web = Gtk2::ImageMenuItem->new( $d->get( "Web" ) );
		$menuitem_web->set_sensitive( $gnome_web_photo );
		$menuitem_web->set_image(
			  Gtk2::Image->new_from_pixbuf(
				  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					  "$gscrot_root/share/gscrot/resources/icons/web_image.svg",
					  Gtk2::IconSize->lookup( 'menu' )
				  )
			  )
		);
		$menuitem_web->signal_connect( activate => \&evt_take_screenshot,
									   'tray_web' );
		my $menuitem_info = Gtk2::ImageMenuItem->new( $d->get( "Info" ) );
		$menuitem_info->set_image(
					   Gtk2::Image->new_from_icon_name( 'gtk-about', 'menu' ) );
		$menuitem_info->signal_connect( "activate", \&evt_about, $window );
		my $menuitem_quit = Gtk2::ImageMenuItem->new( $d->get( "Quit" ) );
		$menuitem_quit->set_image(
						Gtk2::Image->new_from_icon_name( 'gtk-quit', 'menu' ) );
		$menuitem_quit->signal_connect( "activate", \&evt_delete_window,
										'menu_quit' );
		$tray_menu->append( $menuitem_select );
		$tray_menu->append( Gtk2::SeparatorMenuItem->new );
		$tray_menu->append( $menuitem_raw );
		$tray_menu->append( Gtk2::SeparatorMenuItem->new );
		$tray_menu->append( $menuitem_window );
		$tray_menu->append( $menuitem_window_sect );
		$tray_menu->append( Gtk2::SeparatorMenuItem->new );
		$tray_menu->append( $menuitem_web );
		$tray_menu->append( Gtk2::SeparatorMenuItem->new );
		$tray_menu->append( $menuitem_info );
		$tray_menu->append( $menuitem_quit );
		$tray_menu->show_all;
		$tray_menu->popup(
						   undef,           # parent menu shell
						   undef,           # parent menu item
						   undef,           # menu pos func
						   undef,           # data
						   $data->button,
						   $data->time
						 );
	}
	return 1;
}

sub evt_plugins {
	my ( $tree, $path, $column ) = @_;
}

sub evt_accounts {
	my ( $tree, $path, $column ) = @_;

	#open browser if register url is clicked
	if ( $column->get_title eq $d->get( "Register" ) ) {
		my $model         = $tree->get_model();
		my $account_iter  = $model->get_iter( $path );
		my $account_value = $model->get_value( $account_iter, 3 );
		&fct_gnome_open( undef, $account_value, undef );
	}
	return 1;
}

sub evt_plugins_toolbar {
	my ( $renderer, $index, $model ) = @_;

	print "\n$renderer, $index, $model\n" if $debug_cparam;

	my $path = Gtk2::TreePath->new_from_string( $index );
	my $iter = $model->get_iter( $path );

	if ( $renderer->get_active ) {
		$model->set( $iter, 2, FALSE );
		$plugins{ $model->get_value( $iter, 9 ) }->{ 'menu' } = FALSE;
	} else {
		$model->set( $iter, 2, TRUE );
		$plugins{ $model->get_value( $iter, 9 ) }->{ 'menu' } = TRUE;
	}

	return 1;
}

sub evt_iconview_sel_changed {
	my ( $iconview, $data ) = @_;

	my @sel_items = $iconview->get_selected_items;

	foreach ( keys %{ $session_start_screen{ 'first_page' } } ) {
		$session_start_screen{ 'first_page' }->{ $_ }
			->set_sensitive( ( scalar @sel_items > 0 ) )
			if $session_start_screen{ 'first_page' }->{ $_ } =~ /button/i;
	}

	return TRUE;
}

sub evt_iconview_item_activated {
	my ( $iconview, $path, $data ) = @_;

	my $iter =
		$session_start_screen{ 'first_page' }->{ 'model' }->get_iter( $path );
	my $key =
		$session_start_screen{ 'first_page' }->{ 'model' }
		->get_value( $iter, 2 );

	$notebook->set_current_page(
			 $notebook->page_num( $session_screens{ $key }->{ 'tab_child' } ) );

	return TRUE;
}

sub evt_show_settings {
	$settings_dialog->show_all;
	my $settings_dialog_response = $settings_dialog->run;
	if ( $settings_dialog_response eq "close" ) {
		$settings_dialog->hide();
		return TRUE;
	} else {
		$settings_dialog->hide();
		return FALSE;
	}
}

sub evt_in_tab {
	my ( $widget, $key ) = @_;
	print "\n$key was emitted by widget $widget\n" if $debug_cparam;

	#single screenshots
	my $current_file;
	if ( $key =~ m/^print\[/ ) {
		$key =~ s/^print//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );

			return 0;
		}
		my $current_file = quotemeta $session_screens{ $key }->{ 'long' };
		system( "gtklp $current_file &" );
		&dlg_status_message(
							 1,
							 $session_screens{ $key }->{ 'filename' } . " "
								 . $d->get( "will be printed" )
						   );
	}
	if ( $key =~ m/^delete\[/ ) {
		$key =~ s/^delete//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );
			&fct_update_tab( $key );
			return 0;
		}
		unlink( $session_screens{ $key }->{ 'long' } );           #delete file
		$notebook->remove_page( $notebook->get_current_page );    #delete tab
		&dlg_status_message(
							 1,
							 $session_screens{ $key }->{ 'filename' } . " "
								 . $d->get( "deleted" )
						   ) if defined( $session_screens{ $key }->{ 'filename' } );
		delete( $session_screens{ $key } );    # delete from hash
		&fct_update_first_tab();
		$window->show_all;
	}
	if ( $key =~ m/^remove\[/ ) {
		$key =~ /^remove(.*)__ind__(.*)__indold__(.*)/;
		$key = $1;
		my $delete_index = $2;
		my $last_index   = $3;
		print "Child: "
			. $notebook->page_num( $session_screens{ $key }->{ 'tab_child' } )
			. "\n"
			if $debug_cparam;
		$notebook->remove_page(
			  $notebook->page_num( $session_screens{ $key }->{ 'tab_child' } ) )
			;    #delete tab
		&dlg_status_message(
							 1,
							 $session_screens{ $key }->{ 'filename' } . " "
								 . $d->get( "removed from session" )
						   ) if defined( $session_screens{ $key }->{ 'filename' } );
		delete( $session_screens{ $key } );    # delete from hash
		&fct_update_first_tab();
		$window->show_all;
	}
	if ( $key =~ m/^reopen\[/ ) {
		$key =~ s/^reopen//;
		my $model          = $progname->get_model();
		my $progname_iter  = $progname->get_active_iter();
		my $progname_value = $model->get_value( $progname_iter, 2 );

		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );
			&fct_update_tab( $key );
			return 0;
		}
		unless ( $progname_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message(
				 $d->get( "No application specified to open the screenshot" ) );
			return FALSE;
		}
		system( "$progname_value '$session_screens{$key}->{'long'}' &" );
		&dlg_status_message(
							 1,
							 $session_screens{ $key }->{ 'filename' } . " "
								 . $d->get( "opened with" ) . " "
								 . $progname_value
						   );

	}
	if ( $key =~ m/^upload\[/ ) {
		$key =~ s/^upload//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );
			&fct_update_tab( $key );
			return 0;
		}
		&dlg_account_chooser_and_upload(
									 $session_screens{ $key }->{ 'filename' } );
	}
	if ( $key =~ m/^draw\[/ ) {
		$key =~ s/^draw//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );

			return 0;
		}
		&fct_start_drawing(
							$session_screens{ $key }->{ 'long' },
							$session_screens{ $key }->{ 'width' },
							$session_screens{ $key }->{ 'height' },
							$session_screens{ $key }->{ 'filetype' },
							$d
						  );
		&fct_update_tab( $key );
	}
	if ( $key =~ m/^rename\[/ ) {
		$key =~ s/^rename//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );
			&fct_update_tab( $key );
			return 0;
		}
		print "Renaming of file "
			. $session_screens{ $key }->{ 'long' }
			. " started\n"
			if $debug_cparam;
		&dlg_status_message(
							 1,
							 $session_screens{ $key }->{ 'filename' } . " "
								 . $d->get( "renamed" )
						   ) if &dlg_rename( $session_screens{ $key }->{ 'long' }, $key );
		&fct_update_tab( $key );
	}
	if ( $key =~ m/^plugin\[/ ) {
		$key =~ s/^plugin//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );
			&fct_update_tab( $key );
			return 0;
		}
		unless ( keys %plugins > 0 ) {
			&dlg_error_message( $d->get( "No plugin installed" ) );
		} else {
			&dlg_plugin( $session_screens{ $key }->{ 'filename' }, $key );
		}
		&fct_update_tab( $key );
	}
	if ( $key =~ m/^clipboard\[/ ) {
		$key =~ s/^clipboard//;
		unless (
				 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
				 )
			   )
		{
			&dlg_status_message(
								 1,
								 $session_screens{ $key }->{ 'filename' } . " "
									 . $d->get( "not found" )
							   );

			return 0;
		}
		my $pixbuf = Gtk2::Gdk::Pixbuf->new_from_file(
										 $session_screens{ $key }->{ 'long' } );
		$clipboard->set_image( $pixbuf );
		&dlg_status_message(
							 1,
							 $session_screens{ $key }->{ 'filename' } . " "
								 . $d->get( "copied to clipboard" )
						   );
	}

	#all screenshots
	if ( $key =~ m/^delete$/ ) {    #tab == all

		$session_start_screen{ 'first_page' }->{ 'view' }->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter =
					$session_start_screen{ 'first_page' }->{ 'model' }
					->get_iter( $path );
				if ( defined $iter ) {
					my $key =
						$session_start_screen{ 'first_page' }->{ 'model' }
						->get_value( $iter, 2 );
					$notebook->remove_page(
								   $notebook->page_num(
									   $session_screens{ $key }->{ 'tab_child' }
								   )
					);
					unlink( $session_screens{ $key }->{ 'long' } );
					delete( $session_screens{ $key } );
				}
			},
			undef
																		   );

		&dlg_status_message( 1, $d->get( "All screenshots deleted" ) );
		&fct_update_first_tab;
		$window->show_all;
	}
	if ( $key =~ m/^remove$/ ) {    #tab == all

		$session_start_screen{ 'first_page' }->{ 'view' }->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter =
					$session_start_screen{ 'first_page' }->{ 'model' }
					->get_iter( $path );
				if ( defined $iter ) {
					my $key =
						$session_start_screen{ 'first_page' }->{ 'model' }
						->get_value( $iter, 2 );
					$notebook->remove_page(
								   $notebook->page_num(
									   $session_screens{ $key }->{ 'tab_child' }
								   )
					);
					delete( $session_screens{ $key } );
				}
			},
			undef
																		   );

		&dlg_status_message( 1, $d->get( "All screenshots removed" ) );
		&fct_update_first_tab;
		$window->show_all;
	}
	if ( $key =~ m/^reopen$/ ) {
		my $model          = $progname->get_model();
		my $progname_iter  = $progname->get_active_iter();
		my $progname_value = $model->get_value( $progname_iter, 2 );
		my $open_files;

		unless ( $progname_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message(
				 $d->get( "No application specified to open the screenshot" ) );
			return FALSE;
		}
		if ( $progname_value =~ /gimp/ ) {

			$session_start_screen{ 'first_page' }->{ 'view' }->selected_foreach(
				sub {
					my ( $view, $path ) = @_;
					my $iter =
						$session_start_screen{ 'first_page' }->{ 'model' }
						->get_iter( $path );
					if ( defined $iter ) {
						my $key =
							$session_start_screen{ 'first_page' }->{ 'model' }
							->get_value( $iter, 2 );
						$open_files .=
							quotemeta $session_screens{ $key }->{ 'long' };
						$open_files .= " ";
					}
				},
				undef
																			   );
			if ( $open_files ne "" ) {
				system( "$progname_value $open_files &" );
			}
		} else {

			$session_start_screen{ 'first_page' }->{ 'view' }->selected_foreach(
				sub {
					my ( $view, $path ) = @_;
					my $iter =
						$session_start_screen{ 'first_page' }->{ 'model' }
						->get_iter( $path );
					if ( defined $iter ) {
						my $key =
							$session_start_screen{ 'first_page' }->{ 'model' }
							->get_value( $iter, 2 );
						system(
							"$progname_value '$session_screens{$key}->{'long'}' &"
						);
					}
				},
				undef
																			   );
		}
		&dlg_status_message( 1,
				   $d->get( "Opened all files with" ) . " " . $progname_value );
	}

	if ( $key =~ m/^print$/ ) {    #tab == all
		my $print_files;
		$session_start_screen{ 'first_page' }->{ 'view' }->selected_foreach(
			sub {
				my ( $view, $path ) = @_;
				my $iter =
					$session_start_screen{ 'first_page' }->{ 'model' }
					->get_iter( $path );
				if ( defined $iter ) {
					my $key =
						$session_start_screen{ 'first_page' }->{ 'model' }
						->get_value( $iter, 2 );
					$print_files .=
						quotemeta $session_screens{ $key }->{ 'long' };
					$print_files .= " ";
				}

			},
			undef
																		   );
		if ( $print_files ne "" ) {
			system( "gtklp $print_files &" );
			&dlg_status_message( 1, $d->get( "Printing all screenshots" ) );
		}

	}

}

sub evt_open {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	my $fs =
		Gtk2::FileChooserDialog->new(
							  $d->get( "Choose file to open" ), $window, 'open',
							  'gtk-ok'     => 'accept',
							  'gtk-cancel' => 'reject'
		);
	$fs->set_select_multiple( TRUE );
	my $filter = Gtk2::FileFilter->new;
	$filter->set_name( "*.png / *.jpeg" );
	$filter->add_pattern( "*.png" );
	$filter->add_pattern( "*.jpeg" );
	$fs->add_filter( $filter );
	my $fs_resp = $fs->run;

	if ( $fs_resp eq "accept" ) {
		my @new_file = $fs->get_filenames;
		foreach ( @new_file ) {
			&fct_integrate_screenshot_in_notebook( $_ );
		}
		$fs->destroy();
		return TRUE;
	} else {
		$fs->destroy();
		return FALSE;
	}

}

sub evt_close {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	my $key = &fct_get_current_file;
	$notebook->remove_page(
			 $notebook->page_num( $session_screens{ $key }->{ 'tab_child' } ) );
	&dlg_status_message(
						 1,
						 $session_screens{ $key }->{ 'filename' } . " "
							 . $d->get( "removed from session" )
					   ) if defined( $session_screens{ $key }->{ 'filename' } );
	delete( $session_screens{ $key } );    # delete from hash
	&fct_update_first_tab();
	$window->show_all;

	return TRUE;
}

sub evt_close_all {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	foreach my $key ( keys %session_screens ) {
		$notebook->remove_page(
			 $notebook->page_num( $session_screens{ $key }->{ 'tab_child' } ) );
		delete( $session_screens{ $key } );
	}
	&dlg_status_message( 1, $d->get( "All screenshots removed" ) );
	&fct_update_first_tab;
	$window->show_all;

	return TRUE;
}

sub evt_save_as {
	my ( $widget, $data ) = @_;
	print "\n$data was emitted by widget $widget\n" if $debug_cparam;

	my $fs =
		Gtk2::FileChooserDialog->new(
							  $d->get( "Choose file to open" ), $window, 'save',
							  'gtk-ok'     => 'accept',
							  'gtk-cancel' => 'reject'
		);
	my $fs_resp = $fs->run;

	if ( $fs_resp eq "accept" ) {
		my $filename = $fs->get_filename;

		my $key = &fct_get_current_file;
		unless ( &fct_file_exists( $filename ) ) {
			copy( $session_screens{ $key }->{ 'long' }, $filename );
			&fct_update_tab( $key );
		} else {

			if (
				 &dlg_question_message(
						$filename . "\n\n"
							. $d->get(
							"File already exists.\nDo you want to overwrite it?"
							)
				 )
			   )
			{
				copy( $session_screens{ $key }->{ 'long' }, $filename );
				$session_screens{ $key }->{ 'filename' } = $filename;
				&fct_create_thumbnail_and_fileinfos( $filename, $key );
				&fct_update_tab( $key );

				$fs->destroy();
				return TRUE;
			}
			$fs->destroy();
			return FALSE;
		}
		$session_screens{ $key }->{ 'filename' } = $filename;
		&fct_create_thumbnail_and_fileinfos( $filename, $key );

		$fs->destroy();
		return TRUE;
	} else {
		$fs->destroy();
		return FALSE;
	}
}

sub evt_save_profile {
	my ( $widget, $combobox_settings_profiles ) = @_;
	my $curr_profile_name = $combobox_settings_profiles->get_active_text
		|| "";
	my $new_profile_name =
		&dlg_profile_name( $curr_profile_name, $combobox_settings_profiles );

	if ( $new_profile_name ) {
		if ( $curr_profile_name ne $new_profile_name ) {
			$combobox_settings_profiles->prepend_text( $new_profile_name );
			$combobox_settings_profiles->set_active( 0 );
		}
		&fct_save_settings( $new_profile_name );
	}
	return TRUE;
}

sub evt_delete_profile {
	my ( $widget, $combobox_settings_profiles ) = @_;
	if ( $combobox_settings_profiles->get_active_text ) {
		my $active_text  = $combobox_settings_profiles->get_active_text;
		my $active_index = $combobox_settings_profiles->get_active;
		unlink( "$ENV{'HOME'}/.gscrot/profiles/" . $active_text . ".xml" );
		unlink(
			"$ENV{'HOME'}/.gscrot/profiles/" . $active_text . "_accounts.xml" );

		unless (
				 &fct_file_exists(
						"$ENV{'HOME'}/.gscrot/profiles/" . $active_text . ".xml"
				 )
				 || &fct_file_exists(
									        "$ENV{'HOME'}/.gscrot/profiles/"
										  . $active_text
										  . "_accounts.xml"
									)
			   )
		{
			$combobox_settings_profiles->remove_text( $active_index );
			$combobox_settings_profiles->set_active(
								  $combobox_settings_profiles->get_active + 1 );

			&dlg_status_message( 1, $d->get( "Profile deleted" ) );
		} else {
			&dlg_error_message( $d->get( "Profile could not be deleted" ) );
			&dlg_status_message( 1, $d->get( "Profile could not be deleted" ) );
		}
	}
	return TRUE;
}

sub evt_apply_profile {
	my ( $widget, $combobox_settings_profiles ) = @_;
	if ( $combobox_settings_profiles->get_active_text ) {
		&fct_load_settings( undef, 'profile_load',
							$combobox_settings_profiles->get_active_text );
	}
	return TRUE;
}

#--------------------------------------


#functions
#--------------------------------------

sub fct_create_session_notebook {
	$notebook->set_scrollable( TRUE );
	$notebook->signal_connect( 'switch-page' => \&evt_notebook_switch,
							   'tab-switched' );
	$notebook->set_size_request( 430, 320 );
	my $hbox_first_label = Gtk2::HBox->new( FALSE, 0 );
	my $thumb_first_icon =
		Gtk2::Image->new_from_pixbuf(
					Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
						"$gscrot_root/share/gscrot/resources/icons/session.svg",
						Gtk2::IconSize->lookup( 'menu' ), TRUE
					)
		);
	my $tab_first_label = Gtk2::Label->new( $d->get( "Session" ) );
	$hbox_first_label->pack_start( $thumb_first_icon, FALSE, TRUE, 1 );
	$hbox_first_label->pack_start( $tab_first_label,  TRUE,  TRUE, 1 );
	$hbox_first_label->show_all;
	my $first_page =
		$notebook->append_page( fct_create_tab( "", TRUE ), $hbox_first_label );
	return 1;
}

sub fct_integrate_screenshot_in_notebook {
	my ( $filename ) = @_;

	#append a page to notebook using with label == filename
	my ( $second, $minute, $hour ) = localtime();
	my $theTime = "$hour:$minute:$second";
	my $key     = "[" . &fct_get_latest_tab_key . "] - $theTime";

	#create thumbnail for gui
	if ( &fct_create_thumbnail_and_fileinfos( $filename, $key ) ) {

		#build hash of screenshots during session
		$session_screens{ $key }->{ 'filename' } = $filename;

		my $hbox_tab_label = Gtk2::HBox->new( FALSE, 0 );
		my $close_icon = Gtk2::Image->new_from_icon_name( 'gtk-close', 'menu' );
		print "Trying to create tab icon for $filename ...\n"
			if $debug_cparam;
		$session_screens{ $key }->{ 'tab_icon' } =
			Gtk2::Image->new_from_pixbuf( $session_screens{ $key }->{ 'thumb' }
				  ->scale_simple( Gtk2::IconSize->lookup( 'menu' ), 'tiles' ) );
		print "...tab icon for $filename created!\n" if $debug_cparam;
		my $tab_close_button = Gtk2::Button->new;
		$tab_close_button->set_relief( 'none' );
		$tab_close_button->set_image( $close_icon );
		my $tab_label = Gtk2::Label->new( $key );
		$hbox_tab_label->pack_start( $session_screens{ $key }->{ 'tab_icon' },
									 FALSE, TRUE, 1 );
		$hbox_tab_label->pack_start( $tab_label,        TRUE,  TRUE, 1 );
		$hbox_tab_label->pack_start( $tab_close_button, FALSE, TRUE, 1 );
		$hbox_tab_label->show_all;

		#and append page with label == key
		my $new_index =
			$notebook->append_page( fct_create_tab( $key, FALSE ),
									$hbox_tab_label );
		$session_screens{ $key }->{ 'tab_child' } =
			$notebook->get_nth_page( $new_index );
		$tab_close_button->signal_connect(
										   clicked => \&evt_in_tab,
										   'remove' 
											   . $key
											   . '__ind__'
											   . $new_index
											   . '__indold__'
											   . $notebook->get_current_page
										 );

		$notebook->set_tab_detachable(
									  $session_screens{ $key }->{ 'tab_child' },
									  TRUE );

		$window->show_all unless $is_in_tray;

		$notebook->set_current_page( $new_index );

	}

	return $key;
}

sub fct_set_toolbar_sensitive {
	my ( $set ) = @_;

	#set all buttons insensitive/sensitive
	$button_select_menu->set_sensitive( $set );
	$button_raw_menu->set_sensitive( $set );
	$button_window_menu->set_sensitive( $set );
	$button_window_sect->set_sensitive( $set );
	$button_web_menu->set_sensitive( $set ) if ( $gnome_web_photo );

	return 1;
}

sub fct_create_tab {
	my ( $key, $is_all ) = @_;

	my $scrolled_window = Gtk2::ScrolledWindow->new;
	$scrolled_window->set_policy( 'automatic', 'automatic' );
	$scrolled_window->set_shadow_type( 'in' );

	my $vbox_tab          = Gtk2::VBox->new( FALSE, 0 );
	my $hbox_tab          = Gtk2::HBox->new( FALSE, 0 );
	my $vbox_all          = Gtk2::VBox->new( FALSE, 0 );
	my $vbox_fileinfos    = Gtk2::VBox->new( FALSE, 0 );
	my $vbox_fileinfos2   = Gtk2::VBox->new( FALSE, 0 );
	my $hbox_tab_file     = Gtk2::HBox->new( FALSE, 0 );
	my $hbox_tab_actions  = Gtk2::HBox->new( FALSE, 0 );
	my $hbox_tab_actions2 = Gtk2::HBox->new( FALSE, 0 );

	my $tabtoolbar = Gtk2::Toolbar->new;
	$tabtoolbar->set_orientation( 'horizontal' );
	$tabtoolbar->set_show_arrow( TRUE );
	$tabtoolbar->set_style( 'icons' );
	$tabtoolbar->set_icon_size( 'button' );

	my $button_remove =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
														   'gtk-close', 'button'
							   ),
							   undef
							 );
	$button_remove->signal_connect( clicked => \&evt_in_tab,
									'remove' . $key );
	my $tooltip_remove = Gtk2::Tooltips->new;
	$tooltip_remove->set_tip( $button_remove,
							  $d->get( "Remove file(s) from session" ) );

	my $button_delete =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
														  'gtk-delete', 'button'
							   ),
							   undef
							 );
	$button_delete->signal_connect( clicked => \&evt_in_tab,
									'delete' . $key );
	my $tooltip_delete = Gtk2::Tooltips->new;
	$tooltip_delete->set_tip( $button_delete, $d->get( "Delete file(s)" ) );

	my $button_clipboard =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
															'gtk-copy', 'button'
							   ),
							   undef
							 );
	$button_clipboard->signal_connect( clicked => \&evt_in_tab,
									   'clipboard' . $key );
	my $tooltip_clipboard = Gtk2::Tooltips->new;
	$tooltip_clipboard->set_tip( $button_clipboard,
								 $d->get( "Copy file(s) to clipboard" ) );

	my $button_reopen =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
														'gtk-redo-ltr', 'button'
							   ),
							   undef
							 );
	$button_reopen->signal_connect( clicked => \&evt_in_tab,
									'reopen' . $key );
	my $tooltip_reopen = Gtk2::Tooltips->new;
	$tooltip_reopen->set_tip( $button_reopen, $d->get( "Open file(s)" ) );

	my $button_upload =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
														   'gtk-go-up', 'button'
							   ),
							   undef
							 );
	$button_upload->signal_connect( clicked => \&evt_in_tab,
									'upload' . $key );
	my $tooltip_upload = Gtk2::Tooltips->new;
	$tooltip_upload->set_tip( $button_upload,
							  $d->get( "Upload file to hosting-site" ) );

	my $button_rename =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
															'gtk-edit', 'button'
							   ),
							   undef
							 );
	$button_rename->signal_connect( clicked => \&evt_in_tab,
									'rename' . $key );
	my $tooltip_rename = Gtk2::Tooltips->new;
	$tooltip_rename->set_tip( $button_rename, $d->get( "Rename file" ) );

	my $button_plugin =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
														 'gtk-execute', 'button'
							   ),
							   undef
							 );
	$button_plugin->signal_connect( clicked => \&evt_in_tab,
									'plugin' . $key );
	my $tooltip_plugin = Gtk2::Tooltips->new;
	$tooltip_plugin->set_tip( $button_plugin, $d->get( "Execute a plugin" ) );

	my $button_draw =
		Gtk2::ToolButton->new(
				   Gtk2::Image->new_from_pixbuf(
					   Gtk2::Gdk::Pixbuf->new_from_file_at_size(
						   "$gscrot_root/share/gscrot/resources/icons/draw.svg",
						   Gtk2::IconSize->lookup( 'button' )
					   )
				   ),
				   undef
		);
	$button_draw->signal_connect( clicked => \&evt_in_tab, 'draw' . $key );
	my $tooltip_draw = Gtk2::Tooltips->new;
	$tooltip_draw->set_tip( $button_draw, $d->get( "Draw" ) );

	my $button_print =
		Gtk2::ToolButton->new(
							   Gtk2::Image->new_from_icon_name(
														   'gtk-print', 'button'
							   ),
							   undef
							 );
	$button_print->signal_connect( clicked => \&evt_in_tab,
								   'print' . $key );
	my $tooltip_print = Gtk2::Tooltips->new;

	if ( $gtklp ) {
		$tooltip_print->set_tip( $button_print, $d->get( "Print file(s)" ) );
	} else {
		$tooltip_print->set_tip(
								 $button_print,
								 $d->get(
									 "gtklp needs to be installed for this feature"
								 )
							   );
		$button_print->set_sensitive( $gtklp );
	}

	unless ( $is_all ) {
		my $filename_label = Gtk2::Label->new;
		$filename_label->set_markup( "<b>" . $d->get( "Filename" ) . "</b>" );
		$session_screens{ $key }->{ 'filename_label' } =
			Gtk2::Label->new( $session_screens{ $key }->{ 'short' } );
		$session_screens{ $key }->{ 'filename_label' }->set_width_chars( 20 );
		$session_screens{ $key }->{ 'filename_label' }->set_line_wrap( 1 );
		$session_screens{ $key }->{ 'filename_label' }
			->set_line_wrap_mode( 'char' );
		$session_screens{ $key }->{ 'tooltip_filename_tab' } =
			Gtk2::Tooltips->new;
		$session_screens{ $key }->{ 'tooltip_filename_tab' }
			->set_tip( $session_screens{ $key }->{ 'filename_label' },
					   $session_screens{ $key }->{ 'filename' } );
		my $mime_type_label = Gtk2::Label->new;
		$mime_type_label->set_markup( "<b>" . $d->get( "Mime-Type" ) . "</b>" );
		$session_screens{ $key }->{ 'mime_type_label' } =
			Gtk2::Label->new( $session_screens{ $key }->{ 'mime_type' } );
		my $size_label = Gtk2::Label->new;
		$size_label->set_markup( "<b>" . $d->get( "Filesize" ) . "</b>" );
		$session_screens{ $key }->{ 'size_label' } = Gtk2::Label->new(
				  sprintf( "%.2f", $session_screens{ $key }->{ 'size' } / 1024 )
					  . " KB" );
		my $geometry_label = Gtk2::Label->new;
		$geometry_label->set_markup( "<b>" . $d->get( "Geometry" ) . "</b>" );
		$session_screens{ $key }->{ 'geometry_label' } =
			Gtk2::Label->new(   $session_screens{ $key }->{ 'width' } . "x"
							  . $session_screens{ $key }->{ 'height' } );

		if ( &fct_file_exists( $session_screens{ $key }->{ 'filename' } ) ) {
			$session_screens{ $key }->{ 'image' } =
				Gtk2::Image->new_from_pixbuf(
										$session_screens{ $key }->{ 'thumb' } );
		} else {
			$session_screens{ $key }->{ 'image' } =
				Gtk2::Image->new_from_pixbuf(
				Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					"$gscrot_root/share/gscrot/resources/icons/Image-missing.svg",
					Gtk2::IconSize->lookup( 'dialog' )
				)
				);
		}
		$session_screens{ $key }->{ 'image' }->{ 'current_width' } =
			$session_screens{ $key }->{ 'image' }->get_pixbuf->get_width;
		$session_screens{ $key }->{ 'image' }->{ 'current_height' } =
			$session_screens{ $key }->{ 'image' }->get_pixbuf->get_height;
		$session_screens{ $key }->{ 'image' }->{ 'aspect_ratio' } =
			$session_screens{ $key }->{ 'image' }->{ 'current_width' } /
			$session_screens{ $key }->{ 'image' }->{ 'current_height' };
		$session_screens{ $key }->{ 'image' }
			->signal_connect_after( 'expose-event', \&fct_resize_thumb, $key )
			unless ( $is_all );

		#packing
		my $tab_infos_sizegroup = Gtk2::SizeGroup->new( 'vertical' );
		$tab_infos_sizegroup->add_widget(
							   $session_screens{ $key }->{ 'filename_label' } );
		$tab_infos_sizegroup->add_widget(
								   $session_screens{ $key }->{ 'size_label' } );
		$tab_infos_sizegroup->add_widget(
							  $session_screens{ $key }->{ 'mime_type_label' } );
		$tab_infos_sizegroup->add_widget(
							   $session_screens{ $key }->{ 'geometry_label' } );

		$vbox_fileinfos->pack_start( $filename_label, FALSE, TRUE, 5 );
		$vbox_fileinfos->pack_start(
								 $session_screens{ $key }->{ 'filename_label' },
								 FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $size_label, FALSE, TRUE, 10 );
		$vbox_fileinfos->pack_start( $session_screens{ $key }->{ 'size_label' },
									 FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $mime_type_label, FALSE, TRUE, 10 );
		$vbox_fileinfos->pack_start(
								$session_screens{ $key }->{ 'mime_type_label' },
								FALSE, TRUE, 2 );
		$vbox_fileinfos->pack_start( $geometry_label, FALSE, TRUE, 10 );
		$vbox_fileinfos->pack_start(
								 $session_screens{ $key }->{ 'geometry_label' },
								 FALSE, TRUE, 2 );

		$session_screens{ $key }->{ 'scrolled_window' } = $scrolled_window;
		$session_screens{ $key }->{ 'btn_delete' }      = $button_delete;
		$session_screens{ $key }->{ 'btn_reopen' }      = $button_reopen;
		$session_screens{ $key }->{ 'btn_upload' }      = $button_upload;
		$session_screens{ $key }->{ 'btn_print' }       = $button_print;
		$session_screens{ $key }->{ 'btn_rename' }      = $button_rename;
		$session_screens{ $key }->{ 'btn_plugin' }      = $button_plugin;
		$session_screens{ $key }->{ 'btn_draw' }        = $button_draw;
		$session_screens{ $key }->{ 'btn_clipboard' }   = $button_clipboard;

		$tabtoolbar->insert( $button_reopen,               -1 );
		$tabtoolbar->insert( $button_rename,               -1 );
		$tabtoolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
		$tabtoolbar->insert( $button_clipboard,            -1 );
		$tabtoolbar->insert( $button_print,                -1 );
		$tabtoolbar->insert( $button_upload,               -1 );
		$tabtoolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
		$tabtoolbar->insert( $button_plugin,               -1 );
		$tabtoolbar->insert( $button_draw,                 -1 );
		$tabtoolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
		$tabtoolbar->insert( $button_delete,               -1 );

		#add plugins to toolbar
		my $first_plugin = TRUE;
		foreach ( keys %plugins ) {
			if ( $plugins{ $_ }->{ 'menu' } ) {
				my $btn =
					Gtk2::ToolButton->new(
								   Gtk2::Image->new_from_pixbuf(
									   Gtk2::Gdk::Pixbuf->new_from_file_at_size(
											  $plugins{ $_ }->{ 'pixbuf' },
											  Gtk2::IconSize->lookup( 'button' )
									   )
								   ),
								   undef
					);
				my $data = [
							 $plugins{ $_ }->{ 'binary' },
							 $plugins{ $_ }->{ 'name' },
							 $plugins{ $_ }->{ 'lang' },
							 $key,
							 undef
						   ];
				my $tooltip_btn = Gtk2::Tooltips->new;
				$tooltip_btn->set_tip( $btn, $plugins{ $_ }->{ 'tooltip' } );
				$btn->signal_connect( 'clicked', \&fct_execute_plugin, $data );

				if ( $first_plugin ) {
					$first_plugin = FALSE;
					$tabtoolbar->insert( Gtk2::SeparatorToolItem->new,
										 $tabtoolbar->get_n_items - 2 );
				}
				$tabtoolbar->insert( $btn, $tabtoolbar->get_n_items - 2 );
				$session_screens{ $key }->{ $btn } = $btn;

				#disable button if filetype is not supported
				$btn->set_sensitive( FALSE )
					unless $plugins{ $_ }->{ 'ext' } =~
						/$session_screens{$key}->{'filetype'}/;
			}
		}

		$vbox_tab->pack_start( $tabtoolbar, FALSE, TRUE, 1 );


		$hbox_tab_file->pack_start( $session_screens{ $key }->{ 'image' },
									TRUE, TRUE, 10 );
		$hbox_tab_file->pack_start( $vbox_fileinfos,  FALSE, TRUE, 1 );
		$hbox_tab_file->pack_start( $vbox_fileinfos2, FALSE, TRUE, 1 );

		$vbox_tab->pack_start( $hbox_tab_file, TRUE, TRUE, 1 );
		$scrolled_window->add_with_viewport( $vbox_tab );
	} else {
		my $stats_label = Gtk2::Label->new;
		$stats_label->set_markup( "<b>" . $d->get( "Statistic" ) . "</b>" );
		$session_start_screen{ 'first_page' }->{ 'statistics_counter' } =
			Gtk2::Label->new(
							  $notebook->get_n_pages . " "
								  . $d->nget(
											  "screenshot during this session",
											  "screenshots during this session",
											  $notebook->get_n_pages
											)
							);
		$session_start_screen{ 'first_page' }->{ 'size_counter' } =
			Gtk2::Label->new( "0.00 KB" );
		$vbox_all->pack_start( $stats_label, FALSE, TRUE, 1 );
		$vbox_all->pack_start(
				$session_start_screen{ 'first_page' }->{ 'statistics_counter' },
				FALSE, TRUE, 1 );
		$vbox_all->pack_start(
					  $session_start_screen{ 'first_page' }->{ 'size_counter' },
					  FALSE, TRUE, 1 );

		#create iconview for session
		my $viewmodel =
			Gtk2::ListStore->new( 'Gtk2::Gdk::Pixbuf', 'Glib::String',
								  'Glib::String' );
		foreach ( keys %session_screens ) {
			$viewmodel->set(
							 $viewmodel->append,                  0,
							 $session_screens{ $_ }->{ 'thumb' }, 1,
							 $session_screens{ $_ }->{ 'short' }, 2,
							 $_
						   );
		}
		my $view = Gtk2::IconView->new_with_model( $viewmodel );
		$view->set_orientation( 'horizontal' );
		$view->set_pixbuf_column( 0 );
		$view->set_text_column( 1 );
		$view->set_selection_mode( 'multiple' );
		$view->set_columns( 0 );
		$view->signal_connect( 'selection-changed', \&evt_iconview_sel_changed,
							   'sel_changed' );
		$view->signal_connect( 'item-activated', \&evt_iconview_item_activated,
							   'item_activated' );

		$session_start_screen{ 'first_page' }->{ 'scrolled_window' } =
			$scrolled_window;
		$session_start_screen{ 'first_page' }->{ 'view' }  = $view;
		$session_start_screen{ 'first_page' }->{ 'model' } = $viewmodel;
		$session_start_screen{ 'first_page' }->{ 'btn_remove' } =
			$button_remove;
		$session_start_screen{ 'first_page' }->{ 'btn_delete' } =
			$button_delete;
		$session_start_screen{ 'first_page' }->{ 'btn_reopen' } =
			$button_reopen;
		$session_start_screen{ 'first_page' }->{ 'btn_print' } = $button_print;


		#all buttons start insensitive
		foreach ( keys %{ $session_start_screen{ 'first_page' } } ) {
			$session_start_screen{ 'first_page' }->{ $_ }
				->set_sensitive( FALSE )
				if $session_start_screen{ 'first_page' }->{ $_ } =~ /button/i;
		}


		$tabtoolbar->insert( $button_reopen,               -1 );
		$tabtoolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
		$tabtoolbar->insert( $button_print,                -1 );
		$tabtoolbar->insert( Gtk2::SeparatorToolItem->new, -1 );
		$tabtoolbar->insert( $button_remove,               -1 );
		$tabtoolbar->insert( $button_delete,               -1 );

		$vbox_tab->pack_start( $tabtoolbar, FALSE, TRUE, 1 );
		$vbox_tab->pack_start( $vbox_all,   FALSE, TRUE, 1 );

		my $scrolled_window_view = Gtk2::ScrolledWindow->new;
		$scrolled_window_view->set_policy( 'automatic', 'automatic' );
		$scrolled_window_view->set_shadow_type( 'in' );
		$scrolled_window_view->add( $view );

		$vbox_tab->pack_start( $scrolled_window_view, TRUE, TRUE, 0 );
		$scrolled_window->add_with_viewport( $vbox_tab );
	}
	return $scrolled_window;
}

sub fct_resize_thumb {
	my ( $widget, $event, $key ) = @_;
	print "\n$event was emitted by widget $widget\n" if $debug_cparam;
	if ( defined $widget ) {
		my $image = undef;
		my $thumb = undef;
		my $space = 0;
		unless ( $key eq 'is_all' ) {
			$image = $session_screens{ $key }->{ 'image' };
			$thumb = $session_screens{ $key }->{ 'thumb' };
			$space = 50;
		} else {
			$image = $session_start_screen{ 'first_page' }->{ 'image' };
			$thumb = $session_start_screen{ 'first_page' }->{ 'thumb' };
			$space = 100;
		}
		my $old_width  = $image->{ 'current_width' };
		my $old_height = $image->{ 'current_height' };
		$image->{ 'current_height' } = $widget->allocation->height - $space;
		$image->{ 'current_width' } =
			$image->{ 'current_height' } * $image->{ 'aspect_ratio' };

		while ( $image->{ 'current_width' } >= $widget->allocation->width ) {
			$image->{ 'current_height' } -= 20;
			$image->{ 'current_width' } =
				$image->{ 'current_height' } * $image->{ 'aspect_ratio' };
		}
		if (
			 $old_width != $image->{ 'current_width' }
			 && (    $image->{ 'current_width' } > 0
				  && $image->{ 'current_height' } > 0 )
		   )
		{
			$image->set_from_pixbuf(
									 $thumb->scale_simple(
												   $image->{ 'current_width' },
												   $image->{ 'current_height' },
												   'tiles'
									 )
								   );
		}
	}
	return FALSE;
}

sub fct_save_settings {
	my ( $profilename ) = @_;

	#settings file
	my $settingsfile = "$ENV{ HOME }/.gscrot/settings.xml";
	if ( defined $profilename ) {
		$settingsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename.xml"
			if ( $profilename ne "" );
	}

	#session file
	my $sessionfile = "$ENV{ HOME }/.gscrot/session.xml";

	#accounts file
	my $accountsfile = "$ENV{ HOME }/.gscrot/accounts.xml";
	if ( defined $profilename ) {
		$accountsfile =
			"$ENV{ HOME }/.gscrot/profiles/$profilename\_accounts.xml"
			if ( $profilename ne "" );
	}

	open( SETTFILE, ">$settingsfile" )
		or &dlg_error_message( $d->get( "Settings could not be saved!" ) );

	$settings{ 'general' }->{ 'last_profile' } =
		$combobox_settings_profiles->get_active;
	$settings{ 'general' }->{ 'last_profile_name' } =
		$combobox_settings_profiles->get_active_text || "";

	utf8::encode $settings{ 'general' }->{ 'last_profile_name' };

	$settings{ 'general' }->{ 'filetype' } = $combobox_type->get_active;
	$settings{ 'general' }->{ 'quality' }  = $scale->get_value();
	$settings{ 'general' }->{ 'filename' } = $filename->get_text();

	utf8::encode $settings{ 'general' }->{ 'filename' };

	$settings{ 'general' }->{ 'folder' } = $saveDir_button->get_filename();

	utf8::encode $settings{ 'general' }->{ 'folder' };

	$settings{ 'general' }->{ 'zoom_active' } = $zoom_active->get_active();
	$settings{ 'general' }->{ 'zoom_size' }   = 1
		if ( $zoom_size1->get_active );
	$settings{ 'general' }->{ 'zoom_size' } = 2
		if ( $zoom_size2->get_active );
	$settings{ 'general' }->{ 'zoom_size' } = 3
		if ( $zoom_size3->get_active );

	#determining timeout
	my $web_menu = $button_web_menu->get_menu;
	my @timeouts = $web_menu->get_children;
	my $timeout  = undef;
	foreach ( @timeouts ) {

		if ( $_->get_active ) {
			$timeout = $_->get_children->get_text;
			$timeout =~ /([0-9]+)/;
			$timeout = $1;
		}
	}
	$settings{ 'general' }->{ 'web_timeout' } = $timeout;
	my $model         = $progname->get_model();
	my $progname_iter = $progname->get_active_iter();

	if ( defined $progname_iter ) {
		my $progname_value = $model->get_value( $progname_iter, 2 );
		$settings{ 'general' }->{ 'prog' } = $progname_value;
		utf8::encode $settings{ 'general' }->{ 'prog' };
	}

	$settings{ 'general' }->{ 'prog_active' } = $progname_active->get_active();
	$settings{ 'general' }->{ 'im_colors' } = $combobox_im_colors->get_active();
	$settings{ 'general' }->{ 'im_colors_active' } =
		$im_colors_active->get_active();
	$settings{ 'general' }->{ 'delay' }        = $delay->get_value();
	$settings{ 'general' }->{ 'delay_active' } = $delay_active->get_active();
	$settings{ 'general' }->{ 'resize_operator' } =
		$combobox_thumb_operator->get_active();
	$settings{ 'general' }->{ 'thumbnail' } = $thumbnail->get_value();
	$settings{ 'general' }->{ 'thumbnail_active' } =
		$thumbnail_active->get_active();
	$settings{ 'general' }->{ 'border' }   = $combobox_border->get_active();
	$settings{ 'general' }->{ 'cursor' }   = $combobox_cursor->get_active();
	$settings{ 'general' }->{ 'autohide' } = $hide_active->get_active();
	$settings{ 'general' }->{ 'autocopy' } = $autocopy_active->get_active();
	$settings{ 'general' }->{ 'close_at_close' } =
		$close_at_close_active->get_active();
	$settings{ 'general' }->{ 'save_at_close' } =
		$save_at_close_active->get_active();
	$settings{ 'general' }->{ 'keybinding' } = $keybinding_active->get_active();
	$settings{ 'general' }->{ 'keybinding_sel' } =
		$keybinding_sel_active->get_active();
	$settings{ 'general' }->{ 'capture_key' } = $capture_key->get_text();
	$settings{ 'general' }->{ 'capture_sel_key' } =
		$capture_sel_key->get_text();

	#plugins
	foreach ( keys %plugins ) {
		if ( defined $plugins{ $_ }->{ 'menu' } ) {
			if ( $plugins{ $_ }->{ 'menu' } ) {
				$settings{ 'plugins' }->{ $_ }->{ 'menu' } =
					$plugins{ $_ }->{ 'menu' };
			}
		}
	}

	#settings
	print SETTFILE XMLout( \%settings );

	close( SETTFILE )
		or &dlg_error_message( $d->get( "Settings could not be saved!" ) );

	&dlg_status_message( 1, $d->get( "Settings saved successfully!" ) );

	#session
	open( SESS_FILE, ">$sessionfile" )
		or &dlg_error_message( $d->get( "Session could not be saved!" ) );

	#we need to clean the hashkeys, so they become parseable
	my %clean_files;
	my $counter = 0;
	foreach ( sort keys %session_screens ) {

		if ( &fct_file_exists( $session_screens{ $_ }->{ 'long' } ) ) {
			$clean_files{ "file" . $counter }{ 'filename' } =
				$session_screens{ $_ }->{ 'long' };
			$counter++;
		}
	}

	print SESS_FILE XMLout( \%clean_files );

	close( SESS_FILE )
		or &dlg_error_message( $d->get( "Session could not be saved!" ) );

	#accounts
	open( ACC_FILE, ">$accountsfile" )
		or
		&dlg_error_message( $d->get( "Account-settings could not be saved!" ) );

	foreach ( keys %accounts ) {
		$accounts{ $_ }->{ 'password' } = ""
			if $accounts{ $_ }->{ 'host' } =~ /imageshack/i;
	}

	print ACC_FILE XMLout( \%accounts );

	close( ACC_FILE )
		or
		&dlg_error_message( $d->get( "Account-settings could not be saved!" ) );

	return 1;
}

sub fct_save_bindings {

	my $client = Gnome2::GConf::Client->get_default;
	my $shortcut_full =
		"/apps/metacity/global_keybindings/run_command_screenshot";
	my $shortcut_sel =
		"/apps/metacity/global_keybindings/run_command_window_screenshot";
	my $command_full = "/apps/metacity/keybinding_commands/command_screenshot";
	my $command_sel =
		"/apps/metacity/keybinding_commands/command_window_screenshot";

	#set gconf values
	if ( $keybinding_active->get_active() ) {
		$client->set( $command_full,
					  { type => 'string', value => "$gscrot_path --full", } );
		$client->set(
					  $shortcut_full,
					  {
						 type  => 'string',
						 value => $capture_key->get_text(),
					  }
					);
	} else {
		$client->set( $command_full,
					  { type => 'string', value => 'gnome-screenshot', } );
		$client->set( $shortcut_full, { type => 'string', value => 'Print', } );
	}
	if ( $keybinding_sel_active->get_active() ) {
		$client->set(
					  $command_sel,
					  {
						 type  => 'string',
						 value => "$gscrot_path --window",
					  }
					);
		$client->set(
					  $shortcut_sel,
					  {
						 type  => 'string',
						 value => $capture_sel_key->get_text(),
					  }
					);
	} else {
		$client->set(
					  $command_sel,
					  {
						 type  => 'string',
						 value => 'gnome-screenshot --window',
					  }
					);
		$client->set( $shortcut_sel,
					  { type => 'string', value => '<Alt>Print', } );
	}

	return 1;
}

sub fct_load_settings {
	my ( $widget, $data, $profilename ) = @_;

	#settings file
	my $settingsfile = "$ENV{ HOME }/.gscrot/settings.xml";
	$settingsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename.xml"
		if ( defined $profilename );

	my $settings_xml;
	if ( &fct_file_exists( $settingsfile ) ) {
		eval {
			$settings_xml = XMLin( $settingsfile );

			if ( $data eq 'profile_load' ) {
				$combobox_type->set_active(
								 $settings_xml->{ 'general' }->{ 'filetype' } );
				$scale->set_value(
								  $settings_xml->{ 'general' }->{ 'quality' } );
				utf8::decode $settings_xml->{ 'general' }->{ 'filename' };
				$filename->set_text(
								 $settings_xml->{ 'general' }->{ 'filename' } );
				utf8::decode $settings_xml->{ 'general' }->{ 'folder' };
				$saveDir_button->set_current_folder(
								   $settings_xml->{ 'general' }->{ 'folder' } );
				$zoom_active->set_active(
							  $settings_xml->{ 'general' }->{ 'zoom_active' } );
				$zoom_size1->set_active( TRUE )
					if $settings_xml->{ 'general' }->{ 'zoom_size' } == 1;
				$zoom_size2->set_active( TRUE )
					if $settings_xml->{ 'general' }->{ 'zoom_size' } == 2;
				$zoom_size3->set_active( TRUE )
					if $settings_xml->{ 'general' }->{ 'zoom_size' } == 3;

				#determining timeout
				my $web_menu = $button_web_menu->get_menu;
				my @timeouts = $web_menu->get_children;
				my $timeout  = undef;
				foreach ( @timeouts ) {
					$timeout = $_->get_children->get_text;
					$timeout =~ /([0-9]+)/;
					$timeout = $1;
					if ( $settings_xml->{ 'general' }->{ 'web_timeout' } ==
						 $timeout )
					{
						$_->set_active( TRUE );
					}
				}
				my $model = $progname->get_model;
				utf8::decode $settings_xml->{ 'general' }->{ 'prog' };
				$model->foreach( \&fct_iter_programs,
								 $settings_xml->{ 'general' }->{ 'prog' } );
				$progname_active->set_active(
							  $settings_xml->{ 'general' }->{ 'prog_active' } );
				$im_colors_active->set_active(
						 $settings_xml->{ 'general' }->{ 'im_colors_active' } );
				$combobox_im_colors->set_active(
								$settings_xml->{ 'general' }->{ 'im_colors' } );
				$delay->set_value( $settings_xml->{ 'general' }->{ 'delay' } );
				$delay_active->set_active(
							 $settings_xml->{ 'general' }->{ 'delay_active' } );
				$combobox_thumb_operator->set_active(
						  $settings_xml->{ 'general' }->{ 'resize_operator' } );
				$thumbnail->set_value(
								$settings_xml->{ 'general' }->{ 'thumbnail' } );
				$thumbnail_active->set_active(
						 $settings_xml->{ 'general' }->{ 'thumbnail_active' } );
				$combobox_border->set_active(
								   $settings_xml->{ 'general' }->{ 'border' } );
				$combobox_cursor->set_active(
								   $settings_xml->{ 'general' }->{ 'cursor' } );
				$hide_active->set_active(
								 $settings_xml->{ 'general' }->{ 'autohide' } );
				$autocopy_active->set_active(
								 $settings_xml->{ 'general' }->{ 'autocopy' } );
				$close_at_close_active->set_active(
						   $settings_xml->{ 'general' }->{ 'close_at_close' } );
				$save_at_close_active->set_active(
							$settings_xml->{ 'general' }->{ 'save_at_close' } );
				$keybinding_active->set_active(
							   $settings_xml->{ 'general' }->{ 'keybinding' } );
				$keybinding_sel_active->set_active(
						   $settings_xml->{ 'general' }->{ 'keybinding_sel' } );
				$capture_key->set_text(
							  $settings_xml->{ 'general' }->{ 'capture_key' } );
				$capture_sel_key->set_text(
						  $settings_xml->{ 'general' }->{ 'capture_sel_key' } );

			}

			#load account data
			&fct_load_accounts( $profilename );
			if ( defined $accounts_tree ) {
				&fct_load_accounts_tree;
				$accounts_tree->set_model( $accounts_model );
				&fct_set_model_accounts( $accounts_tree );
			}

			#restore session, only once
			&fct_load_session unless ( $profilename );

			&dlg_status_message( 1, $d->get( "Settings loaded successfully" ) );
			}

	}
	if ( $@ ) {
		&dlg_error_message(
					   $d->get( "Settings could not be restored!" ) . " : $@" );
		unlink $settingsfile;
	}

	#plugins
	foreach ( keys %plugins ) {
		if ( defined $settings_xml->{ 'plugins' }->{ $_ } ) {
			if ( $settings_xml->{ 'plugins' }->{ $_ }->{ 'menu' } ) {
				$plugins{ $_ }->{ 'menu' } = TRUE;
			} else {
				$plugins{ $_ }->{ 'menu' } = FALSE;
			}
		} else {
			$plugins{ $_ }->{ 'menu' } = FALSE;
		}
	}
	if ( defined $effects_tree ) {
		&fct_load_plugin_tree;
		$effects_tree->set_model( $effects_model );
		&fct_set_model_plugins( $effects_tree );
	}


	return $settings_xml;
}

sub fct_load_accounts {
	my ( $profilename ) = @_;

	#accounts file
	my $accountsfile = "$ENV{ HOME }/.gscrot/accounts.xml";
	$accountsfile = "$ENV{ HOME }/.gscrot/profiles/$profilename\_accounts.xml"
		if ( defined $profilename );

	my $accounts_xml;
	eval {
		$accounts_xml = XMLin( $accountsfile )
			if &fct_file_exists( $accountsfile );
	};

	if ( $@ ) {
		&dlg_error_message(
			   $d->get( "Account-settings could not be restored!" ) . " : $@" );
		unlink $accountsfile;
	}

	#account data, load defaults if nothing is set
	unless ( exists( $accounts_xml->{ 'ubuntu-pics.de' } ) ) {
		$accounts{ 'ubuntu-pics.de' }->{ host }     = "ubuntu-pics.de";
		$accounts{ 'ubuntu-pics.de' }->{ username } = "";
		$accounts{ 'ubuntu-pics.de' }->{ password } = "";
		$accounts{ 'ubuntu-pics.de' }->{ register } =
			"http://www.ubuntu-pics.de/registrieren.html";
		$accounts{ 'ubuntu-pics.de' }->{ register_color } = "blue";
		$accounts{ 'ubuntu-pics.de' }->{ register_text } =
			( $d->get( "click me" ) );
		$accounts{ 'ubuntu-pics.de' }->{ module } = "UbuntuPics.pm";
	} else {
		$accounts{ 'ubuntu-pics.de' }->{ host } =
			$accounts_xml->{ 'ubuntu-pics.de' }->{ host };
		$accounts{ 'ubuntu-pics.de' }->{ username } =
			$accounts_xml->{ 'ubuntu-pics.de' }->{ username };
		$accounts{ 'ubuntu-pics.de' }->{ password } =
			$accounts_xml->{ 'ubuntu-pics.de' }->{ password };
		$accounts{ 'ubuntu-pics.de' }->{ register } =
			"http://www.ubuntu-pics.de/registrieren.html";
		$accounts{ 'ubuntu-pics.de' }->{ register_color } = "blue";
		$accounts{ 'ubuntu-pics.de' }->{ register_text } =
			( $d->get( "click me" ) );
		$accounts{ 'ubuntu-pics.de' }->{ module } =
			$accounts_xml->{ 'ubuntu-pics.de' }->{ module };
	}

	#account data, load defaults if nothing is set
	unless ( exists( $accounts_xml->{ 'imageshack.us' } ) ) {
		$accounts{ 'imageshack.us' }->{ host }     = "imageshack.us";
		$accounts{ 'imageshack.us' }->{ username } = "";
		$accounts{ 'imageshack.us' }->{ password } = "";
		$accounts{ 'imageshack.us' }->{ register } =
			"http://my.imageshack.us/registration/";
		$accounts{ 'imageshack.us' }->{ register_color } = "blue";
		$accounts{ 'imageshack.us' }->{ register_text } =
			( $d->get( "click me" ) );
	} else {
		$accounts{ 'imageshack.us' }->{ host } =
			$accounts_xml->{ 'imageshack.us' }->{ host };
		$accounts{ 'imageshack.us' }->{ username } =
			$accounts_xml->{ 'imageshack.us' }->{ username };
		$accounts{ 'imageshack.us' }->{ password } =
			$accounts_xml->{ 'imageshack.us' }->{ password };
		$accounts{ 'imageshack.us' }->{ register } =
			"http://my.imageshack.us/registration/";
		$accounts{ 'imageshack.us' }->{ register_color } = "blue";
		$accounts{ 'imageshack.us' }->{ register_text } =
			( $d->get( "click me" ) );
	}
	unless ( exists( $accounts_xml->{ 'imagebanana.com' } ) ) {
		$accounts{ 'imagebanana.com' }->{ host }     = "imagebanana.com";
		$accounts{ 'imagebanana.com' }->{ username } = "";
		$accounts{ 'imagebanana.com' }->{ password } = "";
		$accounts{ 'imagebanana.com' }->{ register } =
			"http://www.imagebanana.com/myib/registrieren/";
		$accounts{ 'imagebanana.com' }->{ register_color } = "blue";
		$accounts{ 'imagebanana.com' }->{ register_text } =
			( $d->get( "click me" ) );
		$accounts{ 'imagebanana.com' }->{ module } = "ImageBanana.pm";
	} else {
		$accounts{ 'imagebanana.com' }->{ host } =
			$accounts_xml->{ 'imagebanana.com' }->{ host };
		$accounts{ 'imagebanana.com' }->{ username } =
			$accounts_xml->{ 'imagebanana.com' }->{ username };
		$accounts{ 'imagebanana.com' }->{ password } =
			$accounts_xml->{ 'imagebanana.com' }->{ password };
		$accounts{ 'imagebanana.com' }->{ register } =
			"http://www.imagebanana.com/myib/registrieren/";
		$accounts{ 'imagebanana.com' }->{ register_color } = "blue";
		$accounts{ 'imagebanana.com' }->{ register_text } =
			( $d->get( "click me" ) );
		$accounts{ 'imagebanana.com' }->{ module } =
			$accounts_xml->{ 'imagebanana.com' }->{ module };
	}
	return TRUE;
}

sub fct_load_session {
	my ( $profilename ) = @_;

	#accounts file
	my $sessionfile = "$ENV{ HOME }/.gscrot/session.xml";

	eval {
		my $session_xml = XMLin( $sessionfile )
			if &fct_file_exists( $sessionfile );

		foreach ( sort keys %{ $session_xml } ) {
			&fct_integrate_screenshot_in_notebook(
										${ $session_xml }{ $_ }{ 'filename' } );
		}

	};
	if ( $@ ) {
		&dlg_error_message(
						$d->get( "Session could not be restored!" ) . " : $@" );
		unlink $sessionfile;
	}


	return TRUE;
}

sub fct_file_exists {
	my ( $filename ) = @_;
	$filename = &fct_switch_home_in_file( $filename );
	return TRUE if ( -f $filename );
	return FALSE;
}

sub fct_switch_home_in_file {
	my ( $filename ) = @_;
	$filename =~ s/^~/$ENV{ HOME }/;    #switch ~ in path to /home/username
	return $filename;
}

sub fct_execute_plugin {

	my $arrayref = $_[ 1 ];
	my ( $plugin_value, $plugin_name, $plugin_lang, $key, $plugin_dialog ) =
		@$arrayref;

	unless ( &fct_file_exists( $session_screens{ $key }->{ 'long' } ) ) {
		&fct_update_tab( $key );
		return FALSE;
	}

	#if it is a native perl plugin, use a plug to integrate it properly
	if ( $plugin_lang eq "perl" ) {
		$plugin_dialog->hide if defined $plugin_dialog;

		#initiate the socket to draw the contents of the plugin to our dialog
		my $plugin_socket = Gtk2::Dialog->new( $plugin_name, $window,
											[ qw/modal destroy-with-parent/ ] );
		my $socket = Gtk2::Socket->new;
		$plugin_socket->vbox->add( $socket );
		$socket->signal_connect(
			'plug-removed' => sub {
				print STDERR "GtkPlug Disconnected\n" if $debug_cparam;
				$plugin_socket->destroy();
				return TRUE;
				1;
			}
		);
		printf( "\n", $socket->get_id );
		my $pid = fork;
		if ( $pid < 0 ) {
			&dlg_error_message(
				  $d->get( "Could not execute plugin" ) . ": " . $plugin_name );
		}
		if ( $pid == 0 ) {
			exec(
				sprintf(
					"$^X $plugin_value %d '$session_screens{$key}->{'long'}' $session_screens{$key}->{'width'} $session_screens{$key}->{'height'} $session_screens{$key}->{'filetype'}\n",
					$socket->get_id )
				);
		}
		$plugin_socket->show_all;
		$plugin_socket->run;

		&dlg_status_message( 1,
			  $d->get( "Successfully executed plugin" ) . ": " . $plugin_name );


		#...if not => simple execute the plugin via system (e.g. shell plugins)
	} else {
		print
			"$plugin_value $session_screens{$key}->{'long'} $session_screens{$key}->{'width'} $session_screens{$key}->{'height'} $session_screens{$key}->{'filetype'} submitted to plugin\n"
			if $debug_cparam;
		if (
			system(
				"'$plugin_value' '$session_screens{$key}->{'long'}' '$session_screens{$key}->{'width'}' '$session_screens{$key}->{'height'}' '$session_screens{$key}->{'filetype'}' "
			) == 0
		   )
		{
			&dlg_status_message(
								 1,
								 $d->get( "Successfully executed plugin" )
									 . ": "
									 . $plugin_name
							   );
		} else {
			&dlg_error_message(
				  $d->get( "Could not execute plugin" ) . ": " . $plugin_name );
		}
	}
	&fct_update_tab( $key );
}

sub fct_usage {
	print "gscrot [options]\n";
	print "Available options:\n\n"
		. "Capture:\n"
		. "--full (starts gscrot and takes a full screen screenshot directly)\n"
		. "--selection (starts gscrot in selection mode)\n"
		. "--window (starts gscrot in window selection mode)\n"
		. "--section (starts gscrot in section selection mode)\n\n"
		.

		"Application:\n"
		. "--min_at_startup (starts gscrot minimized to tray)\n"
		. "--debug (prints a lot of debugging information to STDOUT)\n";
	print "--help (displays this help)\n";
}

sub fct_update_first_tab {
	$session_start_screen{ 'first_page' }->{ 'model' }->clear;
	foreach ( sort keys %session_screens ) {

		#determine size of thumbnail
		my $width = 48;
		my $height =
			$width /
			( $session_screens{ $_ }->{ 'width' } /
			  $session_screens{ $_ }->{ 'height' } );
		my $pixbuf = $session_screens{ $_ }->{ 'thumb' };

		if ( $height > 48 ) {
			$height = 48;
			$width =
				$height *
				( $session_screens{ $_ }->{ 'width' } /
				  $session_screens{ $_ }->{ 'height' } );
		}

		if ( $height < 10 || $width < 10 ) {
			$pixbuf = Gtk2::Gdk::Pixbuf->new_from_file(
						"$gscrot_root/share/gscrot/resources/icons/Image.svg" );
			$width  = 48;
			$height = 48;
		}

		$session_start_screen{ 'first_page' }->{ 'model' }->set(
			$session_start_screen{ 'first_page' }->{ 'model' }->append, 0,
			$pixbuf->scale_simple( $width, $height, 'tiles' ), 1,
			$session_screens{ $_ }->{ 'short' }, 2,
			$_
															   );
	}
	$session_start_screen{ 'first_page' }->{ 'view' }
		->set_model( $session_start_screen{ 'first_page' }->{ 'model' } );
	$session_start_screen{ 'first_page' }->{ 'statistics_counter' }->set_text(
							  scalar( keys( %session_screens ) ) . " "
								  . $d->nget(
											  "screenshot during this session",
											  "screenshots during this session",
											  scalar( keys( %session_screens ) )
											)
	);
	my $total_size = 0;

	foreach ( keys %session_screens ) {
		$total_size += $session_screens{ $_ }->{ 'size' };
	}
	$session_start_screen{ 'first_page' }->{ 'size_counter' }
		->set_text(   $d->get( "Total size" ) . ": "
					. sprintf( "%.2f", $total_size / 1024 )
					. " KB" );

	#if size == 0 => no screenshot in session (handle menu entries properly)
	if ( $menuitem_close_all ) {
		if ( $total_size == 0 ) {
			$menuitem_close_all->set_sensitive( FALSE );
		} else {
			$menuitem_close_all->set_sensitive( TRUE );
		}
	}

	return TRUE;
}

sub fct_get_current_file {

	my $curr_page = $notebook->get_nth_page( $notebook->get_current_page );
	my $key       = undef;
	foreach ( keys %session_screens ) {
		if ( $session_screens{ $_ }->{ 'tab_child' } == $curr_page ) {
			$key = $_;
		}
	}
	return $key;
}

sub fct_update_tab {
	my ( $key ) = @_;
	$key =~ /\[(.*)\]/;

	#update fileinfos
	if (
		 &fct_create_thumbnail_and_fileinfos(
								  $session_screens{ $key }->{ 'filename' }, $key
		 )
	   )
	{

	   #update tab icon - maybe pic changed due to use of plugin or drawing tool
		$session_screens{ $key }->{ 'tab_icon' }
			->set_from_pixbuf( $session_screens{ $key }->{ 'thumb' }
				  ->scale_simple( Gtk2::IconSize->lookup( 'menu' ), 'tiles' ) );
		$session_screens{ $key }->{ 'image' }
			->set_from_pixbuf( $session_screens{ $key }->{ 'thumb' } );
		$session_screens{ $key }->{ 'filename_label' }
			->set_text( $session_screens{ $key }->{ 'short' } );
		$session_screens{ $key }->{ 'tooltip_filename_tab' }
			->set_tip( $session_screens{ $key }->{ 'filename_label' },
					   $session_screens{ $key }->{ 'filename' } );
		$session_screens{ $key }->{ 'mime_type_label' }
			->set_text( $session_screens{ $key }->{ 'mime_type' } );
		$session_screens{ $key }->{ 'size_label' }->set_text(
				  sprintf( "%.2f", $session_screens{ $key }->{ 'size' } / 1024 )
					  . " KB" );
		$session_screens{ $key }->{ 'geometry_label' }
			->set_text(   $session_screens{ $key }->{ 'width' } . "x"
						. $session_screens{ $key }->{ 'height' } );
	} else {

		#update tab icon - file is not existing anymore, maybe deleted manually
		$session_screens{ $key }->{ 'thumb' } =
			Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
				  "$gscrot_root/share/gscrot/resources/icons/Image-missing.svg",
				  400, 400, TRUE );
		$session_screens{ $key }->{ 'tab_icon' }
			->set_from_pixbuf( $session_screens{ $key }->{ 'thumb' }
				  ->scale_simple( Gtk2::IconSize->lookup( 'menu' ), 'tiles' ) );
		$session_screens{ $key }->{ 'image' }
			->set_from_pixbuf( $session_screens{ $key }->{ 'thumb' } );

		foreach ( keys %{ $session_screens{ $key } } ) {
			$session_screens{ $key }->{ $_ }->set_sensitive( FALSE )
				if $session_screens{ $key }->{ $_ } =~ /button/i;
			$session_screens{ $key }->{ $_ }->set_text( "-" )
				if $session_screens{ $key }->{ $_ } =~ /label/i;
		}

	}

	$session_screens{ $key }->{ 'image' }->{ 'current_width' } =
		$session_screens{ $key }->{ 'image' }->get_pixbuf->get_width;
	$session_screens{ $key }->{ 'image' }->{ 'current_height' } =
		$session_screens{ $key }->{ 'image' }->get_pixbuf->get_height;
	$session_screens{ $key }->{ 'image' }->{ 'aspect_ratio' } =
		$session_screens{ $key }->{ 'image' }->{ 'current_width' } /
		$session_screens{ $key }->{ 'image' }->{ 'current_height' };

	&fct_resize_thumb( $session_screens{ $key }->{ 'image' }, undef, $key );

	return TRUE;
}

sub fct_get_latest_tab_key {
	my $max_key = 0;
	foreach my $key ( keys %session_screens ) {
		$key =~ /\[(.*)\]/;
		$max_key = $1 if ( $1 > $max_key );
	}
	return $max_key + 1;
}

sub fct_gnome_open {
	my ( $dialog, $link, $user_data ) = @_;
	system( "gnome-open $link" );

}

sub fct_gnome_open_mail {
	my ( $dialog, $mail, $user_data ) = @_;
	system( "gnome-open mailto:$mail" );
}

sub fct_imagemagick_perform {
	my ( $function, $file, $data ) = @_;
	my $image = Image::Magick->new;
	$file = &fct_switch_home_in_file( $file );
	$image->ReadImage( $file );

	if ( $function eq "reduce_colors" ) {
		$data =~ /.*\(([0-9]*).*\)/;
		$image->Quantize( colors => 2**$1 );
		$image->WriteImage( filename => $file, depth => 8 );
	} elsif ( $function eq "get_object" ) {
		return $image;
	} elsif ( $function eq "get_width" ) {
		return $image->Get( 'columns' );
	} elsif ( $function eq "get_height" ) {
		return $image->Get( 'rows' );
	} elsif ( $function eq "get_mime" ) {
		return $image->Get( 'mime' );
	} elsif ( $function eq "resize" ) {
		$data =~ /(.*)x(.*)/;
		&fct_resize_imagemagick_object( \$image, $1, $2, undef );
		$image->WriteImage( filename => $file );
	}
	return TRUE;
}

sub fct_resize_imagemagick_object {

	#$image is a reference, so dereference it when using it
	my ( $image, $w, $h, $operator ) = @_;
	$operator = $combobox_thumb_operator->get_active
		unless defined $operator;
	if ( $operator == 0 ) {
		$$image->Resize( width => $w, height => $h );
	} elsif ( $operator == 1 ) {
		$$image->Thumbnail( width => $w, height => $h );
	} elsif ( $operator == 2 ) {
		$$image->Sample( width => $w, height => $h );
	} elsif ( $operator == 3 ) {
		$$image->Scale( width => $w, height => $h );
	} elsif ( $operator == 4 ) {
		$$image->AdaptiveResize( width => $w, height => $h );
	}
	return TRUE;
}

sub fct_check_installed_programs {
	print "INFO: checking installed applications...\n";
	foreach ( keys %gm_programs ) {
		unless ( &fct_file_exists( $gm_programs{ $_ }->{ 'binary' } ) ) {
			print " Could not detect binary for program $_, ignoring\n"
				if $debug_cparam;
			delete $gm_programs{ $_ };
			next;
		} else {
			if ( $debug_cparam ) {
				print
					"$gm_programs{$_}->{'name'} - $gm_programs{$_}->{'binary'}\n";
			}
		}
	}
	return TRUE;
}

sub fct_gscrot_area {
	my ( $folder, $filename_value, $filetype_value, $quality_value,
		 $delay_value, $cursor )
		= @_;

	#return value
	my $output = 5;

	#get basic infos
	my $root = Gtk2::Gdk->get_default_root_window;
	my $disp = Gtk2::Gdk::Display->get_default;
	my ( $rootxp, $rootyp, $rootwidthp, $rootheightp, $rootdepthp ) =
		$root->get_geometry;
	my $root_item   = undef;
	my $cursor_item = undef;

	#define zoom window
	my $zoom_size_factor = 1;
	$zoom_size_factor = 2 if ( $zoom_size2->get_active );
	$zoom_size_factor = 3 if ( $zoom_size3->get_active );
	my $zoom_window = Gtk2::Window->new( 'toplevel' );
	$zoom_window->set_decorated( FALSE );
	$zoom_window->set_skip_taskbar_hint( TRUE );
	$zoom_window->set_keep_above( TRUE );
	my ( $zoom_window_width, $zoom_window_height ) = $zoom_window->get_size;
	my ( $zoom_window_x,     $zoom_window_y )      = $zoom_window->get_position;
	my $zoom_window_init = TRUE;

	#pack canvas to a scrolled window
	my $scwin = Gtk2::ScrolledWindow->new();
	$scwin->set_size_request( 100 * $zoom_size_factor,
							  100 * $zoom_size_factor );
	$scwin->set_policy( 'never', 'never' );

	#define and setup the canvas
	my $canvas = Gnome2::Canvas->new();
	$canvas->modify_bg( 'normal',
						Gtk2::Gdk::Color->new( 65535, 65535, 65535 ) );
	$canvas->set_pixels_per_unit( 5 );
	$canvas->set_scroll_region(
								-10 * $zoom_size_factor,
								-10 * $zoom_size_factor,
								$rootwidthp + 50 * $zoom_size_factor,
								$rootheightp + 50 * $zoom_size_factor
							  );
	my $canvas_root = $canvas->root();
	$scwin->add( $canvas );
	my $xlabel    = Gtk2::Label->new( "X: " );
	my $ylabel    = Gtk2::Label->new( "Y: " );
	my $rect      = Gtk2::Label->new( "0 x 0" );
	my $zoom_vbox = Gtk2::VBox->new;
	$zoom_vbox->pack_start_defaults( $scwin );
	$zoom_vbox->pack_start_defaults( $xlabel );
	$zoom_vbox->pack_start_defaults( $ylabel );
	$zoom_vbox->pack_start_defaults( $rect );

	#do some packing
	$zoom_window->add( $zoom_vbox );
	$zoom_window->move( $rootxp, $rootyp );
	$root_item->destroy if defined( $root_item );
	$root_item =
		Gnome2::Canvas::Item->new(
						 $canvas_root,
						 "Gnome2::Canvas::Pixbuf",
						 x => 0,
						 y => 0,
						 pixbuf =>
							 Gtk2::Gdk::Pixbuf->get_from_drawable(
							 $root, undef, 0, 0, 0, 0, $rootwidthp, $rootheightp
																 ),
								 );

	#define gscrot cursor
	my $gscrot_cursor_pixbuf = Gtk2::Gdk::Pixbuf->new_from_file(
				"$gscrot_root/share/gscrot/resources/icons/gscrot_cursor.png" );
	my $gscrot_cursor =
		Gtk2::Gdk::Cursor->new_from_pixbuf( Gtk2::Gdk::Display->get_default,
											$gscrot_cursor_pixbuf, 10, 10 );

	#define graphics context
	my $white = Gtk2::Gdk::Color->new( 65535, 65535, 65535 );
	my $black = Gtk2::Gdk::Color->new( 0,     0,     0 );
	my $gc = Gtk2::Gdk::GC->new( $root, undef );
	$gc->set_line_attributes( 1, 'double-dash', 'round', 'round' );

#	$gc->set_rgb_background( $black->pixel );
#	$gc->set_rgb_foreground( $white->pixel );
	$gc->set_rgb_bg_color( $black );
	$gc->set_rgb_fg_color( $white );
	$gc->set_subwindow( 'include-inferiors' );
	$gc->set_function( 'xor' );
	$gc->set_exposures( TRUE );

	#all screen events are send to gscrot
	my $grab_counter = 0;
	while ( !Gtk2::Gdk->pointer_is_grabbed && $grab_counter < 100 ) {
		Gtk2::Gdk::X11->grab_server unless $zoom_active->get_active;
		Gtk2::Gdk->pointer_grab(
			$root, 0,
			[
			   qw/
				   pointer-motion-mask
				   button-press-mask
				   button1-motion-mask
				   button-release-mask/
			],
			undef,
			$gscrot_cursor,
			Gtk2->get_current_event_time
							   );
		Gtk2::Gdk->keyboard_grab( $root, 0, Gtk2->get_current_event_time );
		$grab_counter++;
	}

	if ( Gtk2::Gdk->pointer_is_grabbed ) {
		my $rx                   = 0;
		my $ry                   = 0;
		my $rw                   = 0;
		my $rh                   = 0;
		my $btn_pressed          = 0;
		my $rect_x               = 0;
		my $rect_y               = 0;
		my $rect_w               = 0;
		my $rect_h               = 0;
		my $rectangle            = undef;
		my $last_selected_window = 0;
		my %smallest_coords      = ();
		my $drawable             = undef;
		Gtk2::Gdk::Event->handler_set(
			sub {
				my ( $event, $data ) = @_;
				return 0 unless defined $event;

				#quit on escape
				if ( $event->type eq 'key-press' ) {
					if ( $event->keyval == $Gtk2::Gdk::Keysyms{ Escape } ) {
						if ( $rect_w > 1 ) {

							#clear the last rectangle
							$root->draw_rectangle( $gc, 0, $rect_x, $rect_y,
												   $rect_w, $rect_h );
						}

						$zoom_window->destroy;
						Gtk2::Gdk->flush;

						#ungrab pointer and keyboard
						Gtk2::Gdk::X11->ungrab_server
							unless $zoom_active->get_active;
						Gtk2::Gdk->pointer_ungrab(
												 Gtk2->get_current_event_time );
						Gtk2::Gdk->keyboard_ungrab(
												 Gtk2->get_current_event_time );
						Gtk2::Gdk::Event->handler_set( undef, 'rect' );
						Gtk2->main_quit;
					}
				} elsif ( $event->type eq 'button-release' ) {
					print "Type: " . $event->type . "\n"
						if ( defined $event && $debug_cparam );
					print
						"Trying to clear a rectangle ($rect_x, $rect_y, $rect_w, $rect_h)\n"
						if $debug_cparam;

					#capture is finished, delete zoom
					$zoom_window->destroy;
					Gtk2::Gdk->flush;

					#ungrab pointer and keyboard
					Gtk2::Gdk::X11->ungrab_server
						unless $zoom_active->get_active;
					Gtk2::Gdk->pointer_ungrab( Gtk2->get_current_event_time );
					Gtk2::Gdk->keyboard_ungrab( Gtk2->get_current_event_time );
					Gtk2::Gdk::Event->handler_set( undef, 'rect' );
					Gtk2->main_quit;

					if ( $rect_w > 1 ) {

						#clear the last rectangle
						$root->draw_rectangle( $gc, 0, $rect_x, $rect_y,
											   $rect_w, $rect_h );
						Gtk2::Gdk->flush;

						#sleep if there is any delay
						sleep $delay_value;

						#get the pixbuf from drawable and save the file
						my $pixbuf =
							Gtk2::Gdk::Pixbuf->get_from_drawable( $root, undef,
														 $rect_x, $rect_y, 0, 0,
														 $rect_w + 1,
														 $rect_h + 1 );

						$pixbuf =
							&fct_include_cursor(
												 $rect_x, $rect_y, $rect_w,
												 $rect_h, $root,   $pixbuf
											   ) if $cursor;

						$output = Image::Magick->new( magick => 'png' );
						$output->BlobToImage(
											 $pixbuf->save_to_buffer( 'png' ) );
					} else {
						$output = 0;
					}
				} elsif ( $event->type eq 'button-press' ) {
					print "Type: " . $event->type . "\n"
						if ( defined $event && $debug_cparam );
					$btn_pressed = 1;
					if ( defined $smallest_coords{ 'last_win' } ) {
						$root->draw_rectangle(
									$gc,
									0,
									$smallest_coords{ 'last_win' }->{ 'x' },
									$smallest_coords{ 'last_win' }->{ 'y' },
									$smallest_coords{ 'last_win' }->{ 'width' },
									$smallest_coords{ 'last_win' }->{ 'height' }
						);
					}

					#rectangle starts here...
					$rx = $event->x;
					$ry = $event->y;
				} elsif ( $event->type eq 'motion-notify' ) {
					print "Type: " . $event->type . "\n"
						if ( defined $event && $debug_cparam );
					$xlabel->set_text( "X: " . $event->x );
					$ylabel->set_text( "Y: " . $event->y );

				#check pos and geometry of the zoom window and move it if needed
					( $zoom_window_width, $zoom_window_height ) =
						$zoom_window->get_size;
					( $zoom_window_x, $zoom_window_y ) =
						$zoom_window->get_position;
					if (
						(
						   ( $event->x >= $zoom_window_x - 150 )
						   && ( $event->x <=
								( $zoom_window_x + $zoom_window_width + 150 ) )
						)
						&& (
							( $event->y >= $zoom_window_y - 150 )
							&& ( $event->y <=
								( $zoom_window_y + $zoom_window_height + 150 ) )
						   )
					   )
					{

						if ( $zoom_window_init ) {
							$zoom_window->move( $rootxp, $rootyp );
							$zoom_window_init = FALSE;
						} else {
							$zoom_window->move( 0,
										   $rootheightp - $zoom_window_height );
							$zoom_window_init = TRUE;
						}
					}

					#~ #draw cursor on the canvas...
					$cursor_item->destroy if defined( $cursor_item );
					$cursor_item =
						Gnome2::Canvas::Item->new(
												$canvas_root,
												"Gnome2::Canvas::Pixbuf",
												x      => $event->x - 10,
												y      => $event->y - 10,
												pixbuf => $gscrot_cursor_pixbuf,
						);

					#...scroll to centered position (*5 because of zoom factor)
					$canvas->scroll_to( $event->x * 5, $event->y * 5 );
					if ( $btn_pressed ) {

						#redraw last rect to clear it
						if ( $rect_w > 0 ) {
							print
								"Trying to clear a rectangle ($rect_x, $rect_y, $rect_w, $rect_h)\n"
								if $debug_cparam;

							$root->draw_rectangle( $gc, 0, $rect_x, $rect_y,
												   $rect_w, $rect_h );

#							Gtk2::Gdk->flush;
						}
						$rect_x = $rx;
						$rect_y = $ry;
						$rect_w = $event->x - $rect_x;
						$rect_h = $event->y - $rect_y;
						if ( $rect_w < 0 ) {
							$rect_x += $rect_w;
							$rect_w = 0 - $rect_w;
						}
						if ( $rect_h < 0 ) {
							$rect_y += $rect_h;
							$rect_h = 0 - $rect_h;
						}

						my $print_w = $rect_w + 1;
						my $print_h = $rect_h + 1;
						$rect->set_text( $print_w . " x " . $print_h );

						#draw new rect to the root window
						if ( $rect_w != 0 ) {
							print
								"Trying to draw a rectangle ($rect_x, $rect_y, $rect_w, $rect_h)\n"
								if $debug_cparam;

							$root->draw_rectangle( $gc, 0, $rect_x, $rect_y,
												   $rect_w, $rect_h );

#							Gtk2::Gdk->flush;
						}
					}
				} else {
					Gtk2->main_do_event( $event );
				}
			},
			'rect'
									 );
		$zoom_window->show_all if $zoom_active->get_active;
		Gtk2->main;
	} else {    #pointer not grabbed
		$zoom_window->destroy;
		Gtk2::Gdk->flush;

		#ungrab pointer and keyboard
		Gtk2::Gdk::X11->ungrab_server unless $zoom_active->get_active;
		Gtk2::Gdk->pointer_ungrab( Gtk2->get_current_event_time );
		Gtk2::Gdk->keyboard_ungrab( Gtk2->get_current_event_time );
	}
	return $output;
}

sub fct_gscrot_window {
	my ( $folder, $filename_value, $filetype_value, $quality_value,
		 $delay_value, $border, $cursor, $mode )
		= @_;

	#return value
	my $output = 5;

	#get basic infos
	$gdk_screen = Gtk2::Gdk::Screen->get_default;
	my $root = Gtk2::Gdk->get_default_root_window;
	my $disp = Gtk2::Gdk::Display->get_default;
	my ( $rootxp, $rootyp, $rootwidthp, $rootheightp ) = $root->get_geometry;

	#get all the windows
	$screen->force_update;
	my @windows = $screen->get_windows;

	#...and window "pick" cursor
	my $hand_cursor2 = Gtk2::Gdk::Cursor->new( 'GDK_HAND2' );

	#define graphics context
	my $white = Gtk2::Gdk::Color->new( 65535, 65535, 65535 );
	my $black = Gtk2::Gdk::Color->new( 0,     0,     0 );
	my $gc = Gtk2::Gdk::GC->new( $root, undef );
	$gc->set_line_attributes( 5, 'solid', 'round', 'round' );
	$gc->set_rgb_bg_color( $black );
	$gc->set_rgb_fg_color( $white );
	$gc->set_subwindow( 'include-inferiors' );
	$gc->set_function( 'xor' );

	my $grab_counter = 0;
	while ( !Gtk2::Gdk->pointer_is_grabbed && $grab_counter < 100 ) {
		Gtk2::Gdk::X11->grab_server;
		Gtk2::Gdk->pointer_grab(
			$root, 0,
			[
			   qw/
				   pointer-motion-mask
				   button-release-mask/
			],
			undef,
			$hand_cursor2,
			Gtk2->get_current_event_time
							   );
		Gtk2::Gdk->keyboard_grab( $root, 0, Gtk2->get_current_event_time );
		$grab_counter++;
	}

	if ( Gtk2::Gdk->pointer_is_grabbed ) {
		my $last_selected_window      = 0;
		my $last_selected_window_wnck = 0;
		my $drawable                  = undef;
		my $window_selected           = FALSE;
		my $ungrabbed                 = FALSE;

		%children = ();
		Gtk2::Gdk::Event->handler_set(
			sub {
				my ( $event, $data ) = @_;
				return 0 unless defined $event;

				#handle key events here
				if ( $event->type eq 'key-press' ) {
					next unless defined $event->keyval;
					if ( $event->keyval == $Gtk2::Gdk::Keysyms{ Escape } ) {

						#clear the last rectangle
						if ( defined $children{ 'last_win' } ) {
							$root->draw_rectangle(
											 $gc,
											 0,
											 $children{ 'last_win' }{ 'x' },
											 $children{ 'last_win' }{ 'y' },
											 $children{ 'last_win' }{ 'width' },
											 $children{ 'last_win' }{ 'height' }
							);
						}

						#ungrab pointer and keyboard
						Gtk2::Gdk::X11->ungrab_server;
						Gtk2::Gdk->pointer_ungrab(
												 Gtk2->get_current_event_time );
						Gtk2::Gdk->keyboard_ungrab(
												 Gtk2->get_current_event_time );
						Gtk2::Gdk::Event->handler_set( undef, 'rect' );
						Gtk2->main_quit;
						$output = 5;
					}
				} elsif ( $event->type eq 'button-release' ) {
					print "Type: " . $event->type . "\n"
						if ( defined $event && $debug_cparam );
					print
						"Trying to clear a rectangle ($children{'last_win'}{'x'}, $children{'last_win'}{'y'}, $children{'last_win'}{'width'}, $children{'last_win'}{'height'})\n"
						if $debug_cparam;

					unless ( $window_selected ) {
						Gtk2::Gdk::X11->ungrab_server;
						$ungrabbed = TRUE;
					}

					#looking for a section of a window?
					#keep current window in mind and search for children
					if ( ( $mode eq "section" || $mode eq "tray_section" )
						 && !$window_selected )
					{
						return 0 unless defined $children{ 'last_win' };
						&fct_query_children(
							 $children{ 'last_win' }{ 'gdk_window' }->XWINDOW,
							 $children{ 'last_win' }{ 'gdk_window' }->XWINDOW );

						#focus selected window (maybe it is hidden)
						$children{ 'last_win' }{ 'gdk_window' }->focus( time );
						Gtk2::Gdk->flush;
						$window_selected =
							$children{ 'curr_win' }{ 'gdk_window' };

						return TRUE;
					}

					#clear the last rectangle
					if ( defined $children{ 'last_win' } ) {
						$root->draw_rectangle(
											 $gc,
											 0,
											 $children{ 'last_win' }{ 'x' },
											 $children{ 'last_win' }{ 'y' },
											 $children{ 'last_win' }{ 'width' },
											 $children{ 'last_win' }{ 'height' }
						);

						#focus selected window (maybe it is hidden)
						$children{ 'last_win' }{ 'gdk_window' }->focus( time );
						Gtk2::Gdk->flush;
						sleep 1 if $delay_value < 1;

						#ungrab pointer and keyboard
						Gtk2::Gdk::X11->ungrab_server unless $ungrabbed;
						Gtk2::Gdk->pointer_ungrab(
												 Gtk2->get_current_event_time );
						Gtk2::Gdk->keyboard_ungrab(
												 Gtk2->get_current_event_time );
						Gtk2::Gdk::Event->handler_set( undef, 'rect' );
						Gtk2->main_quit;


						#sleep if there is any delay
						sleep $delay_value;

						#get the pixbuf from drawable and save the file
						#maybe window is partially not on the screen
						$children{ 'curr_win' }{ 'width' } -=
							$children{ 'curr_win' }{ 'x' } +
							$children{ 'curr_win' }{ 'width' } -
							$rootwidthp
							if ( $children{ 'curr_win' }{ 'x' } +
							 $children{ 'curr_win' }{ 'width' } > $rootwidthp );
						$children{ 'curr_win' }{ 'height' } -=
							$children{ 'curr_win' }{ 'y' } +
							$children{ 'curr_win' }{ 'height' } -
							$rootheightp
							if ( $children{ 'curr_win' }{ 'y' } +
								 $children{ 'curr_win' }{ 'height' } >
								 $rootheightp );
						if ( $children{ 'curr_win' }{ 'x' } < $rootxp ) {
							$children{ 'curr_win' }{ 'width' } =
								$children{ 'curr_win' }{ 'width' } +
								$children{ 'curr_win' }{ 'x' };
							$children{ 'curr_win' }{ 'x' } = 0;
						}
						if ( $children{ 'curr_win' }{ 'y' } < $rootyp ) {
							$children{ 'curr_win' }{ 'height' } =
								$children{ 'curr_win' }{ 'height' } +
								$children{ 'curr_win' }{ 'y' };
							$children{ 'curr_win' }{ 'y' } = 0;
						}

						#...take it
						my $pixbuf =
							Gtk2::Gdk::Pixbuf->get_from_drawable(
											 $root,
											 undef,
											 $children{ 'curr_win' }{ 'x' },
											 $children{ 'curr_win' }{ 'y' },
											 0,
											 0,
											 $children{ 'curr_win' }{ 'width' },
											 $children{ 'curr_win' }{ 'height' }
							);

#						my ( $qroot, $qparent, @qkids ) = undef;
#						my $xwindow = $children{ 'curr_win' }{ 'gdk_window' }->XWINDOW;
#						my $last_parent = $children{ 'curr_win' }{ 'gdk_window' }->XWINDOW;
#						while(1){
#							( $qroot, $qparent, @qkids ) = $x->QueryTree( $xwindow );
#							my ($ordering, $rectangles) = $x->ShapeGetRectangles($last_parent, 'Bounding');
#							print Dumper($rectangles);
#							unless ($qroot == $qparent){
#							$last_parent = $qparent;
#							$xwindow = $qparent;
#							}else{
#								last;
#							}
#						}

						$pixbuf =
							&fct_include_cursor(
											$children{ 'curr_win' }{ 'x' },
											$children{ 'curr_win' }{ 'y' },
											$children{ 'curr_win' }{ 'width' },
											$children{ 'curr_win' }{ 'height' },
											$root,
											$pixbuf
							) if $cursor;

						$output = Image::Magick->new( magick => 'png' );
						$output->BlobToImage(
											 $pixbuf->save_to_buffer( 'png' ) );
					} else {
						$output = 0;
					}
				} elsif ( $event->type eq 'motion-notify' ) {
					print "Type: " . $event->type . "\n"
						if ( defined $event && $debug_cparam );
					my $min_x = $rootwidthp;
					my $min_y = $rootheightp;

					#if there is no window already selected
					unless ( $window_selected ) {
						print "Searching for window...\n" if $debug_cparam;
						foreach my $curr_window ( @windows ) {
							$drawable = Gtk2::Gdk::Window->foreign_new(
														$curr_window->get_xid );
							next unless defined $drawable;

							#do not detect gscrot window when it is hidden
							next
								if ( $curr_window->get_xid ==
									 $window->window->get_xid && $is_in_tray );

#							if($curr_window->is_visible_on_workspace ($screen->get_active_workspace)){
							my ( $xp, $yp, $widthp, $heightp, $depthp ) =
								( 0, 0, 0, 0, undef );
							if ( $border ) {
								( $xp, $yp, $widthp, $heightp ) =
									$curr_window->get_geometry;
							} else {
								( $xp, $yp, $widthp, $heightp, $depthp ) =
									$drawable->get_geometry;
								( $xp, $yp ) = $drawable->get_origin;
							}
							print "Current Event x: "
								. $event->x . ", y: "
								. $event->y . "\n"
								if $debug_cparam;
							if (
								 $curr_window->is_visible_on_workspace(
												   $screen->get_active_workspace
								 )
								 && (    ( $event->x >= $xp )
									  && ( $event->x <= ( $xp + $widthp ) ) )
								 && (    ( $event->y >= $yp )
									  && ( $event->y <= ( $yp + $heightp ) ) )
							   )
							{
								if ( ( $xp + $widthp ) * ( $yp + $heightp ) <=
									 $min_x * $min_y )
								{
									print
										"Parent X: $xp, Y: $yp, Width: $widthp, Height: $heightp\n"
										if $debug_cparam;
									$children{ 'curr_win' }{ 'window' } =
										$curr_window;
									$children{ 'curr_win' }{ 'gdk_window' } =
										$drawable;
									$children{ 'curr_win' }{ 'x' } = $xp;
									$children{ 'curr_win' }{ 'y' } = $yp;
									$children{ 'curr_win' }{ 'width' } =
										$widthp;
									$children{ 'curr_win' }{ 'height' } =
										$heightp;
									$min_x = $xp + $widthp;
									$min_y = $yp + $heightp;
								}
							}

							#							}
						}    #end if toplevel window loop

						#window selected, search for children now
					} else {
						print "Searching for children now...\n"
							if $debug_cparam;
						if ( defined $children{ 'curr_win' } ) {
							print "Currently smallest window: "
								. $children{ 'curr_win' }{ 'window' }->get_name
								. "\n"
								if $debug_cparam;
							print
								"Curr. Parent X: $children{'curr_win'}{'x'}, Y: $children{'curr_win'}{'y'}, Width: $children{'curr_win'}{'width'}, Height: $children{'curr_win'}{'height'}\n"
								if $debug_cparam;
							if (
								(
								   $mode eq "section" || $mode eq "tray_section"
								)
								and $window_selected
							   )
							{
								print "QueryPointer for current window...\n"
									if $debug_cparam;
								if (
									 defined $children{ 'curr_win' }
									 { 'gdk_window' } )
								{

									#selected window is parent
									my $curr_parent = $window_selected->XWINDOW;
									foreach my $curr_child (
										   keys %{ $children{ $curr_parent } } )
									{
										next unless defined $curr_child;
										print "Child Current Event x: "
											. $event->x . ", y: "
											. $event->y . "\n"
											if $debug_cparam;
										if (
											(
											   (
												  $event->x >=
												  $children{ $curr_parent }
												  { $curr_child }{ 'x' }
											   )
											   && (
												   $event->x <= (
													   $children{ $curr_parent }
														   { $curr_child }
														   { 'x' } +
														   $children{
														   $curr_parent }
														   { $curr_child }
														   { 'width' }
												   )
												  )
											)
											&& (
												 (
												   $event->y >=
												   $children{ $curr_parent }
												   { $curr_child }{ 'y' }
												 )
												 && (
													 $event->y <= (
														 $children{ $curr_parent
															 }{ $curr_child }
															 { 'y' } +
															 $children{
															 $curr_parent }
															 { $curr_child }
															 { 'height' }
													 )
													)
											   )
										   )
										{
											if (
												(
												   $children{ $curr_parent }
												   { $curr_child }{ 'x' } +
												   $children{ $curr_parent }
												   { $curr_child }{ 'width' }
												) * (
													$children{ $curr_parent }
														{ $curr_child }{ 'y' } +
														$children{ $curr_parent
														}{ $curr_child }
														{ 'height' }
												) <= $min_x * $min_y
											   )
											{
												$children{ 'curr_win' }
													{ 'gdk_window' } =
													$children{ $curr_parent }
													{ $curr_child }
													{ 'gdk_window' };
												$children{ 'curr_win' }{ 'x' } =
													$children{ $curr_parent }
													{ $curr_child }{ 'x' };
												$children{ 'curr_win' }{ 'y' } =
													$children{ $curr_parent }
													{ $curr_child }{ 'y' };
												$children{ 'curr_win' }
													{ 'width' } =
													$children{ $curr_parent }
													{ $curr_child }{ 'width' };
												$children{ 'curr_win' }
													{ 'height' } =
													$children{ $curr_parent }
													{ $curr_child }{ 'height' };
												$min_x =
													$children{ $curr_parent }
													{ $curr_child }{ 'x' } +
													$children{ $curr_parent }
													{ $curr_child }{ 'width' };
												$min_y =
													$children{ $curr_parent }
													{ $curr_child }{ 'y' } +
													$children{ $curr_parent }
													{ $curr_child }{ 'height' };
											}
										}
									}
								}
							}
						}
					}    #endif search for children

					#draw rect if needed
					if ( $last_selected_window ne
						 $children{ 'curr_win' }{ 'gdk_window' } )
					{

						#clear last rectangle
						if ( defined $children{ 'last_win' } ) {
							$root->draw_rectangle(
											 $gc,
											 0,
											 $children{ 'last_win' }{ 'x' },
											 $children{ 'last_win' }{ 'y' },
											 $children{ 'last_win' }{ 'width' },
											 $children{ 'last_win' }{ 'height' }
							);
							Gtk2::Gdk->flush;
						}

						#draw new rectangle for current window
						$root->draw_rectangle(
										 $gc,
										 0,
										 $children{ 'curr_win' }{ 'x' } - 3,
										 $children{ 'curr_win' }{ 'y' } - 3,
										 $children{ 'curr_win' }{ 'width' } + 5,
										 $children{ 'curr_win' }{ 'height' } + 5
						);
						$last_selected_window =
							$children{ 'curr_win' }{ 'gdk_window' };
						$last_selected_window_wnck =
							$children{ 'curr_win' }{ 'window' };
						$children{ 'last_win' }{ 'window' } =
							$children{ 'curr_win' }{ 'window' };
						$children{ 'last_win' }{ 'gdk_window' } =
							$children{ 'curr_win' }{ 'gdk_window' };
						$children{ 'last_win' }{ 'x' } =
							$children{ 'curr_win' }{ 'x' } - 3;
						$children{ 'last_win' }{ 'y' } =
							$children{ 'curr_win' }{ 'y' } - 3;
						$children{ 'last_win' }{ 'width' } =
							$children{ 'curr_win' }{ 'width' } + 5;
						$children{ 'last_win' }{ 'height' } =
							$children{ 'curr_win' }{ 'height' } + 5;
					}    #endif drawing rectangle
				} else {
					Gtk2->main_do_event( $event );
				}
			},
			'window'
									 );
		Gtk2->main;
	} else {    #pointer not grabbed

		#ungrab pointer and keyboard
		Gtk2::Gdk::X11->ungrab_server;
		Gtk2::Gdk->pointer_ungrab( Gtk2->get_current_event_time );
		Gtk2::Gdk->keyboard_ungrab( Gtk2->get_current_event_time );
	}
	return $output;
}

sub fct_query_children {
	my ( $xwindow, $xparent ) = @_;
	my ( $qroot, $qparent, @qkids ) = $x->QueryTree( $xwindow );
	foreach ( @qkids ) {

		#~ print "$qroot, $qparent, $_, $xwindow\n";
		my $gdk_window = Gtk2::Gdk::Window->foreign_new( $_ );
		if ( defined $gdk_window ) {

			#window needs to be viewable and visible
			next unless $gdk_window->is_visible;
			next unless $gdk_window->is_viewable;

			#min size
			my ( $xp, $yp, $widthp, $heightp, $depthp ) =
				$gdk_window->get_geometry;
			( $xp, $yp ) = $gdk_window->get_origin;
			next if ( $widthp * $heightp < 4 );

			#check if $gdk_window is dublicate
			my $dub = FALSE;
			foreach my $checkchild ( keys %{ $children{ $xparent } } ) {
				$dub = TRUE
					if $children{ $xparent }{ $checkchild }{ 'gdk_window' } ==
						$gdk_window;
			}
			unless ( $dub == TRUE ) {
				$children{ $xparent }{ $_ }{ 'gdk_window' } = $gdk_window;
				$children{ $xparent }{ $_ }{ 'x' }          = $xp;
				$children{ $xparent }{ $_ }{ 'y' }          = $yp;
				$children{ $xparent }{ $_ }{ 'width' }      = $widthp;
				$children{ $xparent }{ $_ }{ 'height' }     = $heightp;
				$children{ $xparent }{ $_ }{ 'size' } = $widthp * $heightp;

				#check next depth
				fct_query_children( $gdk_window->XWINDOW, $xparent );
			}
		}
	}
	return 1;
}

sub fct_gscrot_window_direct {
	my ( $folder, $filename_value, $filetype_value, $quality_value,
		 $delay_value, $border, $cursor, $curr_xid )
		= @_;
	my $drawable    = Gtk2::Gdk::Window->foreign_new( $curr_xid );
	my $curr_window = Gnome2::Wnck::Window->get( $curr_xid );
	my $root        = Gtk2::Gdk->get_default_root_window;
	my ( $rootxp, $rootyp, $rootwidthp, $rootheightp ) = $root->get_geometry;
	my ( $xp, $yp, $widthp, $heightp, $depthp ) = ( 0, 0, 0, 0, undef );

	if ( $border ) {
		( $xp, $yp, $widthp, $heightp ) = $curr_window->get_geometry;
	} else {
		( $xp, $yp, $widthp, $heightp, $depthp ) = $drawable->get_geometry;
		( $xp, $yp ) = $drawable->get_origin;
	}

	#focus selected window (maybe it is hidden)
	$drawable->focus( time );
	Gtk2::Gdk->flush;
	sleep 1 if $delay_value < 1;

	#sleep if there is any delay
	sleep $delay_value;

	#get the pixbuf from drawable and save the file
	#maybe window is partially not on the screen
	$widthp -= $xp + $widthp - $rootwidthp
		if ( $xp + $widthp > $rootwidthp );
	$heightp -= $yp + $heightp - $rootheightp
		if ( $yp + $heightp > $rootheightp );
	if ( $xp < $rootxp ) {
		$widthp = $widthp + $xp;
		$xp     = 0;
	}
	if ( $yp < $rootyp ) {
		$heightp = $heightp + $yp;
		$yp      = 0;
	}
	my $pixbuf =
		Gtk2::Gdk::Pixbuf->get_from_drawable( $root, undef, $xp, $yp, 0, 0,
											  $widthp, $heightp );

	$pixbuf = &fct_include_cursor( $xp, $yp, $widthp, $heightp, $root, $pixbuf )
		if $cursor;

	my $output = Image::Magick->new( magick => 'png' );
	$output->BlobToImage( $pixbuf->save_to_buffer( 'png' ) );
	return $output;
}

sub fct_gscrot_workspace {
	my ( $folder, $filename_value, $filetype_value, $quality_value,
		 $delay_value, $border, $cursor, $selected_workspace )
		= @_;
	$active_workspace = $screen->get_active_workspace;
	my $wrksp_changed = FALSE;
	foreach my $space ( @workspaces ) {
		next unless defined $space;
		if (    $selected_workspace == $space->get_number
			 && $selected_workspace != $active_workspace->get_number )
		{
			$space->activate( time );
			$wrksp_changed = TRUE;
		}
	}

	#mh...just sleep until workspace is changed (fixme?)
	if ( $delay_value < 2 && $wrksp_changed ) {
		$delay_value = 2;
	}
	my $root = Gtk2::Gdk->get_default_root_window;
	my ( $rootxp, $rootyp, $rootwidthp, $rootheightp ) = $root->get_geometry;
	( $rootxp, $rootyp ) = $root->get_origin;

	#sleep if there is any delay
	sleep $delay_value;

	#get the pixbuf from drawable and save the file
	my $pixbuf =
		Gtk2::Gdk::Pixbuf->get_from_drawable( $root, undef, $rootxp, $rootyp, 0,
											  0, $rootwidthp, $rootheightp );


	$pixbuf =
		&fct_include_cursor( $rootxp, $rootyp, $rootwidthp, $rootheightp, $root,
							 $pixbuf )
		if $cursor;

	my $output = Image::Magick->new( magick => 'png' );
	$output->BlobToImage( $pixbuf->save_to_buffer( 'png' ) );
	$active_workspace->activate( time ) if $wrksp_changed;
	return $output;
}

#code ported and borrowed from gnome-screenshot
sub fct_include_cursor {

	my ( $xp, $yp, $widthp, $heightp, $gdk_window, $pixbuf ) = @_;

	my $cursor =
		Gtk2::Gdk::Cursor->new_for_display( Gtk2::Gdk::Display->get_default,
											'GDK_LEFT_PTR' );

#	my $cursor_pixbuf =
#		$x->XFixesGetCursorImage( Gtk2::Gdk::Display->get_default );

	my $cursor_pixbuf = $cursor->get_image;

	if ( $cursor_pixbuf ) {
		my ( $window_at_pointer, $x, $y, $mask ) = $gdk_window->get_pointer;

		my $r1 = Gtk2::Gdk::Rectangle->new( $xp, $yp, $widthp, $heightp );
		my $r2 = Gtk2::Gdk::Rectangle->new( $x, $y, $cursor_pixbuf->get_width,
											$cursor_pixbuf->get_height );

		if ( $r2 = $r1->intersect( $r2 ) ) {

			my $dest_y = $r2->y - $yp - 4;
			$dest_y = 0 if ( $dest_y < 0 );
			$cursor_pixbuf->composite(
									   $pixbuf,      $r2->x - $xp,
									   $dest_y,      $r2->width,
									   $r2->height,  $x - 6 - $xp,
									   $y - 4 - $yp, 1.0,
									   1.0,          'bilinear',
									   255
									 );
		}
	}

	return $pixbuf;
}

#_END code ported and borrowed from gnome-screenshot

sub fct_get_max {
	my ( $a, $b ) = @_;
	return $a if ( $a > $b );
	return $b;
}

sub fct_get_next_filename {

	my ( $filename_value, $folder, $filetype_value ) = @_;

	$filename_value =~ s/\\//g;

	#auto increment
	if ( $filename_value =~ /\%N{1,}/ ) {

		#how many Ns are used? (important for formatting)
		my $pos_proc = index( $filename_value, "%", 0 );
		my $n_counter = 0;
		$pos_proc++;

		while ( $pos_proc <= length( $filename_value ) ) {
			if ( index( $filename_value, "N", $pos_proc ) != -1 ) {
				$n_counter++;
				$pos_proc++;
			} else {
				last;
			}
		}
		print "$n_counter Ns used in wild-card\n" if $debug_cparam;
		my $marks = "";
		my $i     = 0;

		while ( $i < $n_counter ) {
			$marks .= "?";
			$i++;
		}

		$filename_value =~ s/\%N{1,}/$marks/g;
		print
			"Searching for files with pattern: $filename_value.$filetype_value\n"
			if $debug_cparam;
		my @files = glob( "$folder/$filename_value.$filetype_value" );
		@files = sort { $b cmp $a } @files;

		if ( $debug_cparam ) {
			foreach ( @files ) {
				print $_. "\n";
			}
		}

		#check pos of %NN
		my $pos = index( "$folder/$filename_value.$filetype_value", "?", 0 );
		my $next_count = 0;
		unless ( $pos == -1 ) {

			foreach ( @files ) {
				$next_count = substr( $_, $pos, $n_counter );
				next unless $next_count =~ /^(\d+\.?\d*|\.\d+)$/;
				print
					"Counter at position $pos - $next_count is currently greatest value...\n"
					if $debug_cparam;
				last;
			}
		}
		$next_count = 0 unless $next_count =~ /^(\d+\.?\d*|\.\d+)$/;
		$next_count = sprintf( "%0" . $n_counter . "d", $next_count + 1 );
		$marks = quotemeta $marks;
		$filename_value =~ s/$marks/$next_count/g;
	}

	#file already exists and user is not using ai
	if ( &fct_file_exists( "$folder/$filename_value.$filetype_value" ) ) {
		my $count             = 1;
		my $existing_filename = $filename_value;
		while ( &fct_file_exists( "$folder/$filename_value.$filetype_value" ) )
		{
			$filename_value =
				$existing_filename . "(" . sprintf( "%03d", $count++ ) . ")";
		}
	}

	return $filename_value;
}

sub fct_check_installed_plugins {
	print "\nINFO: checking installed plugins...\n";
	foreach ( keys %plugins ) {
		if ( $plugins{ $_ }->{ 'binary' } ne "" ) {
			unless ( &fct_file_exists( $plugins{ $_ }->{ 'binary' } ) ) {
				print " Could not detect binary for program $_, ignoring\n";
				delete $plugins{ $_ };
				next;
			}
			if ( $debug_cparam ) {
				$plugins{ $_ }->{ 'name' } = `$plugins{$_}->{'binary'} name`;
				utf8::decode $plugins{ $_ }->{ 'name' };
				chomp( $plugins{ $_ }->{ 'name' } );
				binmode( STDOUT, ":utf8" );
				print "$plugins{$_}->{'name'} - $plugins{$_}->{'binary'}\n";
			}
		} else {
			print "WARNING: Plugin $_ is not configured properly, ignoring\n";
		}
	}
	return TRUE;
}

sub fct_create_thumbnail_and_fileinfos {
	my ( $filename, $key ) = @_;
	return FALSE unless &fct_file_exists( $filename );
	$filename = &fct_switch_home_in_file( $filename );
	$session_screens{ $key }->{ 'thumb' } =
		Gtk2::Gdk::Pixbuf->new_from_file_at_scale( $filename, 400, 400, TRUE );
	$session_screens{ $key }->{ 'thumb' } =
		Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
				  "$gscrot_root/share/gscrot/resources/icons/Image-missing.svg",
				  400, 400, TRUE )
		unless defined $session_screens{ $key }->{ 'thumb' };
	$session_screens{ $key }->{ 'mime_type' } =
		&fct_imagemagick_perform( "get_mime", $filename, "" );
	$session_screens{ $key }->{ 'width' } =
		&fct_imagemagick_perform( "get_width", $filename, 0, "" );
	$session_screens{ $key }->{ 'height' } =
		&fct_imagemagick_perform( "get_height", $filename, 0, "" );
	$session_screens{ $key }->{ 'size' } = -s $filename;

	#short filename
	$session_screens{ $key }->{ 'short' } = $filename;
	$session_screens{ $key }->{ 'short' } =~ s{^.*/}{};

	#long filename
	$session_screens{ $key }->{ 'long' } = $filename;

	#store the filetype of the current screenshot for further processing
	$filename =~ /.*\.(.*)$/;
	$session_screens{ $key }->{ 'filetype' } = $1;
	return TRUE;
}

sub fct_iter_programs {
	my ( $model, $path, $iter, $search_for ) = @_;
	my $progname_value = $model->get_value( $iter, 2 );
	return FALSE if $search_for ne $progname_value;
	$progname->set_active_iter( $iter );
	return TRUE;
}

sub fct_ret_workspace_menu {
	$active_workspace = $screen->get_active_workspace;

	@workspaces = ();
	for ( my $wcount = 0 ; $wcount < $screen->get_workspace_count ; $wcount++ )
	{
		push( @workspaces, $screen->get_workspace( $wcount ) );
	}

	my $menu_wrksp = Gtk2::Menu->new;
	foreach my $space ( @workspaces ) {
		next unless defined $space;
		print "Workspace: "
			. $space->get_name
			. " Viewport X: "
			. $space->get_viewport_x
			. " Viewport Y: "
			. $space->get_viewport_y
			. " Overall "
			. $screen->get_workspace_count
			. " detected\n"
			if $debug_cparam;
		if ( $active_workspace->get_number != $space->get_number ) {
			my $wrkspace_item =
				Gtk2::MenuItem->new_with_label( $space->get_name );
			$wrkspace_item->signal_connect(
									  'activate' => \&evt_take_screenshot,
									  "gscrot_wrksp_direct" . $space->get_number
			);
			$menu_wrksp->append( $wrkspace_item );
		}
	}
	$button_raw_menu->set_menu( $menu_wrksp );
	$menu_wrksp->show_all();
	return $menu_wrksp;
}

sub fct_ret_window_menu {
	my $menu_windows = Gtk2::Menu->new;
	my @windows      = $screen->get_windows;
	foreach my $win ( @windows ) {
		if ( $win->is_visible_on_workspace( $screen->get_active_workspace ) ) {
			my $window_item =
				Gtk2::ImageMenuItem->new_with_label( $win->get_name );
			$window_item->set_image(
						  Gtk2::Image->new_from_pixbuf( $win->get_mini_icon ) );
			$window_item->signal_connect( 'activate' => \&evt_take_screenshot,
										  "gscrot_window_direct" . $win->get_xid
										);
			$menu_windows->append( $window_item );
		}
	}
	$button_window_menu->set_menu( $menu_windows );
	$menu_windows->show_all;
	return $menu_windows;
}

sub fct_ret_sel_menu {
	my $menu_sel = Gtk2::Menu->new;
	$zoom_active =
		Gtk2::CheckMenuItem->new_with_label( $d->get( "Enable zoom window" ) );
	if ( defined $settings_xml->{ 'general' }->{ 'zoom_active' } ) {
		$zoom_active->set_active(
							  $settings_xml->{ 'general' }->{ 'zoom_active' } );
	} else {
		$zoom_active->set_active( TRUE );
	}
	$menu_sel->append( $zoom_active );
	my $menu_size =
		Gtk2::MenuItem->new_with_label( $d->get( "Size of zoom window" ) );
	my $menu_size2 = Gtk2::Menu->new;
	$zoom_size1 = Gtk2::RadioMenuItem->new( undef,       $d->get( "Small" ) );
	$zoom_size2 = Gtk2::RadioMenuItem->new( $zoom_size1, $d->get( "Medium" ) );
	$zoom_size3 = Gtk2::RadioMenuItem->new( $zoom_size1, $d->get( "Large" ) );

	if ( defined $settings_xml->{ 'general' }->{ 'zoom_size' } ) {
		$zoom_size1->set_active( TRUE )
			if $settings_xml->{ 'general' }->{ 'zoom_size' } == 1;
		$zoom_size2->set_active( TRUE )
			if $settings_xml->{ 'general' }->{ 'zoom_size' } == 2;
		$zoom_size3->set_active( TRUE )
			if $settings_xml->{ 'general' }->{ 'zoom_size' } == 3;
	} else {
		$zoom_size1->set_active( TRUE );
	}
	$menu_sel->append( $menu_size );
	$menu_size->set_submenu( $menu_size2 );
	$menu_size2->append( $zoom_size1 );
	$menu_size2->append( $zoom_size2 );
	$menu_size2->append( $zoom_size3 );
	$menu_sel->show_all;
	return $menu_sel;
}

sub fct_ret_web_menu {
	my $menu_web = Gtk2::Menu->new;
	my $timeout1 =
		Gtk2::RadioMenuItem->new( undef, $d->get( "Timeout" ) . ": 5" );
	my $timeout2 =
		Gtk2::RadioMenuItem->new( $timeout1, $d->get( "Timeout" ) . ": 10" );
	my $timeout3 =
		Gtk2::RadioMenuItem->new( $timeout1, $d->get( "Timeout" ) . ": 15" );
	$timeout2->set_active( TRUE );
	$menu_web->append( $timeout1 );
	$menu_web->append( $timeout2 );
	$menu_web->append( $timeout3 );

	if ( defined $settings_xml->{ 'general' }->{ 'web_timeout' } ) {

		#determining timeout
		my @timeouts = $menu_web->get_children;
		my $timeout  = undef;
		foreach ( @timeouts ) {
			$timeout = $_->get_children->get_text;
			$timeout =~ /([0-9]+)/;
			$timeout = $1;
			if ( $settings_xml->{ 'general' }->{ 'web_timeout' } == $timeout ) {
				$_->set_active( TRUE );
			}
		}
	}
	$menu_web->show_all;
	return $menu_web;
}

sub fct_load_accounts_tree {

	$accounts_model =
		Gtk2::ListStore->new(
							  'Glib::String', 'Glib::String',
							  'Glib::String', 'Glib::String',
							  'Glib::String', 'Glib::String',
							  'Glib::String'
							);

	foreach ( keys %accounts ) {
		my $hidden_text = "";
		for ( my $i = 1 ;
			  $i <= length( $accounts{ $_ }->{ 'password' } ) ;
			  $i++ )
		{
			$hidden_text .= '*';
		}
		$accounts_model->set(
							  $accounts_model->append,               0,
							  $accounts{ $_ }->{ 'host' },           1,
							  $accounts{ $_ }->{ 'username' },       2,
							  $hidden_text,                          3,
							  $accounts{ $_ }->{ 'register' },       4,
							  $accounts{ $_ }->{ 'register_color' }, 5,
							  $accounts{ $_ }->{ 'register_text' }
							);
	}

	return TRUE;
}

sub fct_load_plugin_tree {

	$effects_model =
		Gtk2::ListStore->new(
							  'Gtk2::Gdk::Pixbuf', 'Glib::String',
							  'Glib::Boolean',     'Glib::String',
							  'Glib::String',      'Glib::String',
							  'Glib::String',      'Glib::String',
							  'Glib::String',      'Glib::String'
							);
	foreach ( sort keys %plugins ) {
		if ( $plugins{ $_ }->{ 'binary' } ne "" ) {
			my $pixbuf;
			if ( &fct_file_exists( $plugins{ $_ }->{ 'pixbuf' } ) ) {
				$pixbuf =
					Gtk2::Gdk::Pixbuf->new_from_file_at_size(
											 $plugins{ $_ }->{ 'pixbuf' },
											 Gtk2::IconSize->lookup( 'menu' ) );
			} else {
				$pixbuf =
					Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/executable.svg",
					 Gtk2::IconSize->lookup( 'menu' )
					);
			}

			#get translated plugin-name
			$plugins{ $_ }->{ 'name' } = `$plugins{$_}->{'binary'} name`;
			utf8::decode $plugins{ $_ }->{ 'name' };
			$plugins{ $_ }->{ 'category' } = `$plugins{$_}->{'binary'} sort`;
			utf8::decode $plugins{ $_ }->{ 'category' };
			$plugins{ $_ }->{ 'tooltip' } = `$plugins{$_}->{'binary'} tip`;
			utf8::decode $plugins{ $_ }->{ 'tooltip' };
			$plugins{ $_ }->{ 'ext' } = `$plugins{$_}->{'binary'} ext`;
			utf8::decode $plugins{ $_ }->{ 'ext' };
			$plugins{ $_ }->{ 'lang' } = `$plugins{$_}->{'binary'} lang`;
			utf8::decode $plugins{ $_ }->{ 'lang' };
			$plugins{ $_ }->{ 'lang' } = "shell"
				if $plugins{ $_ }->{ 'lang' } eq "";
			chomp( $plugins{ $_ }->{ 'name' } );
			chomp( $plugins{ $_ }->{ 'category' } );
			chomp( $plugins{ $_ }->{ 'tooltip' } );
			chomp( $plugins{ $_ }->{ 'ext' } );
			chomp( $plugins{ $_ }->{ 'lang' } );

			#check if plugin can handle png and/or jpeg
			my $pixbuf_jpeg = 'gtk-no';
			my $pixbuf_png  = 'gtk-no';
			$pixbuf_jpeg = 'gtk-yes'
				if ( $plugins{ $_ }->{ 'ext' } =~ /jpeg/ );
			$pixbuf_png = 'gtk-yes'
				if ( $plugins{ $_ }->{ 'ext' } =~ /png/ );
			$effects_model->set(
								 $effects_model->append,         0,
								 $pixbuf,                        1,
								 $plugins{ $_ }->{ 'name' },     2,
								 $plugins{ $_ }->{ 'menu' },     3,
								 $plugins{ $_ }->{ 'binary' },   4,
								 $plugins{ $_ }->{ 'category' }, 5,
								 $plugins{ $_ }->{ 'tooltip' },  6,
								 $pixbuf_jpeg,                   7,
								 $pixbuf_png,                    8,
								 $plugins{ $_ }->{ 'lang' },     9,
								 $_,
							   );
		} else {
			print "WARNING: Plugin $_ is not configured properly, ignoring\n";
		}
	}

	return TRUE;
}

sub fct_set_model_accounts {
	my $accounts_tree = $_[ 0 ];

	my @columns = $accounts_tree->get_columns;
	foreach ( @columns ) {
		$accounts_tree->remove_column( $_ );
	}

#host
	my $tv_clmn_name_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_name_text->set_title( $d->get( "Host" ) );
	my $renderer_name_accounts = Gtk2::CellRendererText->new;
	$tv_clmn_name_text->pack_start( $renderer_name_accounts, FALSE );
	$tv_clmn_name_text->set_attributes( $renderer_name_accounts, text => 0 );
	$accounts_tree->append_column( $tv_clmn_name_text );

	my $renderer_username_accounts = Gtk2::CellRendererText->new;
	$renderer_username_accounts->set( editable => TRUE );
	$renderer_username_accounts->signal_connect(
		'editing-started' => sub {
			my ( $cell, $cell_editable, $text_path, $model ) = @_;
			my $path = Gtk2::TreePath->new_from_string( $text_path );
			my $iter = $model->get_iter( $path );
			if ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				&dlg_info_message(
					$d->get(
						"If you have registered with imageshack.us, you should have received an email with a link similar to\n\nhttp://reg.imageshack.us/setlogin.php?login=SOME_IDENTIFIER\n\nYou should pass either that link as the username or only the user_id (SOME_IDENTIFIER)\n\nYou do not have to provide a password."
					)
				);
			}
		},
		$accounts_model
											   );
	$renderer_username_accounts->signal_connect(
		'edited' => sub {
			my ( $cell, $text_path, $new_text, $model ) = @_;
			my $path = Gtk2::TreePath->new_from_string( $text_path );
			my $iter = $model->get_iter( $path );
			$accounts{ $model->get_value( $iter, 0 ) }->{ 'username' } =
				$new_text;    #save entered username to the hash

			#imageshack does not need a password
			if ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				$accounts{ $model->get_value( $iter, 0 ) }->{ 'password' } =
					$new_text;
			}

			$model->set( $iter, 1, $new_text );
		},
		$accounts_model
											   );
	my $tv_clmn_username_text =
		Gtk2::TreeViewColumn->new_with_attributes( $d->get( "Username" ),
									   $renderer_username_accounts, text => 1 );
	$tv_clmn_username_text->set_max_width( 100 );
	$accounts_tree->append_column( $tv_clmn_username_text );

	#password
	my $tv_clmn_password_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_password_text->set_max_width( 100 );
	$tv_clmn_password_text->set_title( $d->get( "Password" ) );
	my $renderer_password_accounts = Gtk2::CellRendererText->new;
	$renderer_password_accounts->set( editable => TRUE );
	$renderer_password_accounts->signal_connect(
		'editing-started' => sub {
			my ( $cell, $cell_editable, $text_path, $model ) = @_;
			my $path = Gtk2::TreePath->new_from_string( $text_path );
			my $iter = $model->get_iter( $path );
			if ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				&dlg_info_message(
					$d->get(
						"If you have registered with imageshack.us, you should have received an email with a link similar to\n\nhttp://reg.imageshack.us/setlogin.php?login=SOME_IDENTIFIER\n\nYou should pass either that link as the username or only the user_id (SOME_IDENTIFIER)\n\nYou do not have to provide a password."
					)
				);
			}
		},
		$accounts_model
											   );

	$renderer_password_accounts->signal_connect(
		edited => sub {
			my ( $cell, $text_path, $new_text, $model ) = @_;
			my $path        = Gtk2::TreePath->new_from_string( $text_path );
			my $iter        = $model->get_iter( $path );
			my $hidden_text = "";

			for ( my $i = 1 ; $i <= length( $new_text ) ; $i++ ) {
				$hidden_text .= '*';
			}
			unless ( $model->get_value( $iter, 0 ) =~ /imageshack/i ) {
				$accounts{ $model->get_value( $iter, 0 ) }->{ 'password' } =
					$new_text;    #save entered password to the hash
				$model->set( $iter, 2, $hidden_text );
			} else {
				$model->set( $iter, 2, "" );
			}

		},
		$accounts_model
											   );


	$tv_clmn_password_text->pack_start( $renderer_password_accounts, FALSE );
	$tv_clmn_password_text->set_attributes( $renderer_password_accounts,
											text => 2 );
	$accounts_tree->append_column( $tv_clmn_password_text );

#register
	my $tv_clmn_pix_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_pix_text->set_title( $d->get( "Register" ) );
	my $ren_text = Gtk2::CellRendererText->new();
	$tv_clmn_pix_text->pack_start( $ren_text, FALSE );
	$tv_clmn_pix_text->set_attributes( $ren_text, 'text', ( $d->get( 5 ) ),
									   'foreground', 4 );
	$accounts_tree->append_column( $tv_clmn_pix_text );


	return TRUE;
}

sub fct_set_model_plugins {
	my $effects_tree = $_[ 0 ];

	my @columns = $effects_tree->get_columns;
	foreach ( @columns ) {
		$effects_tree->remove_column( $_ );
	}

	#icon
	$effects_tree->set_tooltip_column( 5 )
		if Gtk2->CHECK_VERSION( 2, 11, 0 );
	my $tv_clmn_pix_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_pix_text->set_title( $d->get( "Icon" ) );
	my $renderer_pix_effects = Gtk2::CellRendererPixbuf->new;
	$tv_clmn_pix_text->pack_start( $renderer_pix_effects, FALSE );
	$tv_clmn_pix_text->set_attributes( $renderer_pix_effects, pixbuf => 0 );
	$effects_tree->append_column( $tv_clmn_pix_text );

#name
	my $tv_clmn_text_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_text_text->set_title( $d->get( "Name" ) );
	my $renderer_text_effects = Gtk2::CellRendererText->new;
	$tv_clmn_text_text->pack_start( $renderer_text_effects, FALSE );
	$tv_clmn_text_text->set_attributes( $renderer_text_effects, text => 1 );

	$effects_tree->append_column( $tv_clmn_text_text );

#menu
	my $tv_clmn_toolbar_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_toolbar_text->set_title( $d->get( "Toolbar" ) );
	my $renderer_toolbar_effects = Gtk2::CellRendererToggle->new;
	$tv_clmn_toolbar_text->pack_start( $renderer_toolbar_effects, FALSE );
	$tv_clmn_toolbar_text->set_attributes( $renderer_toolbar_effects,
										   'active' => 2 );
	$renderer_toolbar_effects->signal_connect( toggled => \&evt_plugins_toolbar,
											   $effects_model );
	$effects_tree->append_column( $tv_clmn_toolbar_text );

#category
	my $tv_clmn_category_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_category_text->set_title( $d->get( "Category" ) );
	my $renderer_category_effects = Gtk2::CellRendererText->new;
	$tv_clmn_category_text->pack_start( $renderer_category_effects, FALSE );
	$tv_clmn_category_text->set_attributes( $renderer_category_effects,
											text => 4 );
	$effects_tree->append_column( $tv_clmn_category_text );

#path
	my $tv_clmn_path_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_path_text->set_title( $d->get( "Path" ) );
	my $renderer_path_effects = Gtk2::CellRendererText->new;
	$tv_clmn_path_text->pack_start( $renderer_path_effects, FALSE );
	$tv_clmn_path_text->set_attributes( $renderer_path_effects, text => 3 );
	$effects_tree->append_column( $tv_clmn_path_text );

#tooltip column
	unless ( Gtk2->CHECK_VERSION( 2, 12, 0 ) ) {
		my $tv_clmn_descr_text = Gtk2::TreeViewColumn->new;
		$tv_clmn_descr_text->set_title( $d->get( "Description" ) );
		my $renderer_descr_effects = Gtk2::CellRendererText->new;
		$tv_clmn_descr_text->pack_start( $renderer_descr_effects, FALSE );
		$tv_clmn_descr_text->set_attributes( $renderer_descr_effects,
											 text => 5 );
		$effects_tree->append_column( $tv_clmn_descr_text );
	}

#jpeg
	my $tv_clmn_jpeg_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_jpeg_text->set_title( "jpeg" );
	my $renderer_jpeg_effects = Gtk2::CellRendererPixbuf->new;
	$tv_clmn_jpeg_text->pack_start( $renderer_jpeg_effects, FALSE );
	$tv_clmn_jpeg_text->set_attributes( $renderer_jpeg_effects, stock_id => 6 );
	$effects_tree->append_column( $tv_clmn_jpeg_text );

#png
	my $tv_clmn_png_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_png_text->set_title( "png" );
	my $renderer_png_effects = Gtk2::CellRendererPixbuf->new;
	$tv_clmn_png_text->pack_start( $renderer_png_effects, FALSE );
	$tv_clmn_png_text->set_attributes( $renderer_png_effects, stock_id => 7 );
	$effects_tree->append_column( $tv_clmn_png_text );

#language
	my $tv_clmn_lang_text = Gtk2::TreeViewColumn->new;
	$tv_clmn_lang_text->set_title( $d->get( "Language" ) );
	my $renderer_lang_effects = Gtk2::CellRendererText->new;
	$tv_clmn_lang_text->pack_start( $renderer_lang_effects, FALSE );
	$tv_clmn_lang_text->set_attributes( $renderer_lang_effects, text => 8 );
	$effects_tree->append_column( $tv_clmn_lang_text );

	return TRUE;
}

sub fct_init {

	#are there any command line params?
	if ( @ARGV > 0 ) {
		my $arg;
		foreach $arg ( @args ) {
			if ( $arg eq "--debug" ) {
				$debug_cparam = TRUE;
			} elsif ( $arg eq "--help" ) {
				&fct_usage();
				exit;
			} elsif ( $arg eq "--min_at_startup" ) {
				$min_cparam = TRUE;
			} elsif ( $arg eq "--section" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach ( @gscrot_pids ) {
					kill RTMAX => $_;
					die;
				}
				$start_with = "section";
			} elsif ( $arg eq "--select" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach ( @gscrot_pids ) {
					kill RTMIN => $_;
					die;
				}
				$start_with = "select";
			} elsif ( $arg eq "--window" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach ( @gscrot_pids ) {
					kill USR2 => $_;
					die;
				}
				$start_with = "window";
			} elsif ( $arg eq "--full" ) {

				#is there already a process of gscrot running?
				my @gscrot_pids = `pidof -o $$ -x $gscrot_path`;
				foreach ( @gscrot_pids ) {
					kill USR1 => $_;
					die;
				}
				$start_with = "raw";
			} else {
				print "\ncommand " . $arg
					. " not recognized --> will be ignored\n";
				&fct_usage();
				exit;
			}
			print "\ncommand " . $arg . " recognized!\n";
		}
	} else {
		print "INFO: no command line parameters set...\n";
	}
	if ( $debug_cparam ) {
		print "\nINFO: gathering system information...";
		print "\n";
		printf "Glib %s \n", $Glib::VERSION;
		printf "Gtk2 %s \n", $Gtk2::VERSION;
		print "\n";

		# The version info stuff appeared in 1.040.
		print "Glib built for "
			. join( ".", Glib->GET_VERSION_INFO )
			. ", running with "
			. join( ".",
					&Glib::major_version, &Glib::minor_version,
					&Glib::micro_version )
			. "\n"
			if $Glib::VERSION >= 1.040;
		print "Gtk2 built for "
			. join( ".", Gtk2->GET_VERSION_INFO )
			. ", running with "
			. join( ".",
					&Gtk2::major_version, &Gtk2::minor_version,
					&Gtk2::micro_version )
			. "\n"
			if $Gtk2::VERSION >= 1.040;
		print "\n";
	}
	print "INFO: searching for dependencies...\n\n";
	if ( system( "which gtklp" ) == 0 ) {
		print "SUCCESS: gtklp is installed on your system!\n\n";
	} else {
		warn
			"ERROR: gtklp is missing --> printing of screenshots will be disabled!\n\n";
		$gtklp = FALSE;
	}
	if ( system( "which gnome-web-photo" ) == 0 ) {
		print "SUCCESS: gnome-web-photo is installed on your system!\n\n";
	} else {
		warn
			"ERROR: gnome-web-photo is missing --> screenshots of websites will be disabled!\n\n";
		$gnome_web_photo = FALSE;
	}

	#an old .gscrot file existing?
	unlink( "$ENV{ 'HOME' }/.gscrot" )
		if ( &fct_file_exists( "$ENV{ 'HOME' }/.gscrot" ) );

	#an old .gscrot/settings.conf file existing?
	unlink( "$ENV{ 'HOME' }/.gscrot/settings.conf" )
		if ( &fct_file_exists( "$ENV{ 'HOME' }/.gscrot/settings.conf" ) );

	#is there already a .gscrot folder?
	mkdir( "$ENV{ 'HOME' }/.gscrot" )
		unless ( -d "$ENV{ 'HOME' }/.gscrot" );

	#...and a profiles folder?
	mkdir "$ENV{'HOME'}/.gscrot/profiles"
		unless ( -d "$ENV{'HOME'}/.gscrot/profiles" );
	%gm_programs =
		do "$gscrot_root/share/gscrot/resources/system/programs.conf";
	if ( &fct_file_exists( "$ENV{ 'HOME' }/.gscrot/programs.conf" ) ) {
		print
			"\nINFO: using custom program settings found at $ENV{ 'HOME' }/.gscrot/programs.conf\n";
		%gm_programs = do "$ENV{ 'HOME' }/.gscrot/programs.conf";
	}
	my @plugins =
		glob( "$gscrot_root/share/gscrot/resources/system/plugins/*/*" );
	foreach ( @plugins ) {
		if ( -d $_ ) {
			my $dir_name = $_;
			$dir_name =~ s{^.*/}{};
			$plugins{ $_ }->{ 'binary' } = "$_/$dir_name"
				if ( &fct_file_exists( "$_/$dir_name" ) );
			$plugins{ $_ }->{ 'pixbuf' } = "$_/$dir_name.png"
				if ( &fct_file_exists( "$_/$dir_name.png" ) );

			#we prefer svgs
			$plugins{ $_ }->{ 'pixbuf' } = "$_/$dir_name.svg"
				if ( &fct_file_exists( "$_/$dir_name.svg" ) );
		}
	}
	my @custom_plugins = glob( "$ENV{'HOME'}/.gscrot/plugins/*/*" );
	foreach ( @custom_plugins ) {
		if ( -d $_ ) {
			my $dir_name = $_;
			$dir_name =~ s{^.*/}{};
			$plugins{ $_ }->{ 'binary' } = "$_/$dir_name"
				if ( &fct_file_exists( "$_/$dir_name" ) );
			$plugins{ $_ }->{ 'pixbuf' } = "$_/$dir_name.png"
				if ( &fct_file_exists( "$_/$dir_name.png" ) );

			#we prefer svgs
			$plugins{ $_ }->{ 'pixbuf' } = "$_/$dir_name.svg"
				if ( &fct_file_exists( "$_/$dir_name.svg" ) );
		}
	}
	return TRUE;
}

#--------------------------------------

#dialogs
#--------------------------------------

sub dlg_status_message {
	my ( $index, $status_text ) = @_;
	$statusbar->push( $index, $status_text );
	return 1;
}

sub dlg_error_message {
	my ( $dlg_error_message ) = @_;
	my $error_dialog =
		Gtk2::MessageDialog->new( $window, [ qw/modal destroy-with-parent/ ],
								  'error', 'ok', $dlg_error_message );
	my $error_response = $error_dialog->run;
	$error_dialog->destroy() if ( $error_response eq "ok" );
	return TRUE;
}

sub dlg_question_message {
	my ( $dlg_question_message ) = @_;
	my $question_dialog =
		Gtk2::MessageDialog->new(
								  $window,
								  [ qw/modal destroy-with-parent/ ],
								  'question',
								  'yes_no',
								  $dlg_question_message
								);
	my $question_response = $question_dialog->run;
	if ( $question_response eq "yes" ) {
		$question_dialog->destroy();
		return TRUE;
	} else {
		$question_dialog->destroy();
		return FALSE;
	}
}

sub dlg_rename {
	my ( $dlg_rename_text, $data ) = @_;
	my $dlg_header = $d->get( "Rename file" );
	my $input_dialog =
		Gtk2::Dialog->new(
						   $dlg_header,
						   $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-apply'  => 'accept',
						   'gtk-cancel' => 'reject'
						 );
	$input_dialog->set_default_response( 'accept' );
	my $new_filename = Gtk2::Entry->new();
	$new_filename->set_activates_default( TRUE );

	my ( $old_file_name, $directory, $ext ) =
		fileparse( $dlg_rename_text, '\..*' );

	my $old_file_name_full = $dlg_rename_text;

	$new_filename->set_text( $old_file_name );
	$input_dialog->vbox->add( $new_filename );
	$input_dialog->show_all;
	my $input_response = $input_dialog->run;

	if ( $input_response eq "accept" ) {
		my $new_name = $new_filename->get_text;
		$dlg_rename_text = $directory . $new_name . $ext;
		unless ( $old_file_name_full eq $dlg_rename_text )
		{    #filenames eq? -> nothing to do here
			unless ( &fct_file_exists( $dlg_rename_text ) ) {
				rename( &fct_switch_home_in_file( $old_file_name_full ),
						&fct_switch_home_in_file( $dlg_rename_text ) );
			} else {

				if (
					&dlg_question_message(
						$dlg_rename_text . "\n\n"
							. $d->get(
							"File already exists.\nDo you want to overwrite it?"
							)
					)
				   )
				{
					rename( &fct_switch_home_in_file( $old_file_name_full ),
							&fct_switch_home_in_file( $dlg_rename_text ) );
					$session_screens{ $data }->{ 'filename' } =
						$dlg_rename_text;
					$input_dialog->destroy();
					return TRUE;
				}
				$input_dialog->destroy();
				return FALSE;
			}
			$session_screens{ $data }->{ 'filename' } = $dlg_rename_text;
		}
		$input_dialog->destroy();
		return TRUE;
	} else {
		$input_dialog->destroy();
		return FALSE;
	}
}

sub dlg_plugin {
	my ( $dlg_plugin_text, $key ) = @_;
	my $dlg_header = $d->get( "Choose a plugin" );
	my $plugin_dialog =
		Gtk2::Dialog->new(
						   $dlg_header,
						   $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-execute' => 'accept',
						   'gtk-cancel'  => 'reject'
						 );
	$plugin_dialog->set_default_response( 'accept' );
	my $model = Gtk2::ListStore->new(
									  'Gtk2::Gdk::Pixbuf', 'Glib::String',
									  'Glib::String',      'Glib::String',
									  'Glib::String',      'Glib::String'
									);

	foreach ( sort keys %plugins ) {
		next
			unless $plugins{ $_ }->{ 'ext' } =~
				/$session_screens{$key}->{'filetype'}/;
		if ( $plugins{ $_ }->{ 'binary' } ne "" ) {
			my $pixbuf;
			if ( -f $plugins{ $_ }->{ 'pixbuf' } ) {
				$pixbuf =
					Gtk2::Gdk::Pixbuf->new_from_file_at_size(
											 $plugins{ $_ }->{ 'pixbuf' },
											 Gtk2::IconSize->lookup( 'menu' ) );
			} else {
				$pixbuf =
					Gtk2::Gdk::Pixbuf->new_from_file_at_size(
					 "$gscrot_root/share/gscrot/resources/icons/executable.svg",
					 Gtk2::IconSize->lookup( 'menu' )
					);
			}

			#get translated plugin-name
			$plugins{ $_ }->{ 'name' } = `$plugins{$_}->{'binary'} name`;
			utf8::decode $plugins{ $_ }->{ 'name' };
			chomp( $plugins{ $_ }->{ 'name' } );

			#get translated plugin-tip
			$plugins{ $_ }->{ 'tip' } = `$plugins{$_}->{'binary'} tip`;
			utf8::decode $plugins{ $_ }->{ 'tip' };
			chomp( $plugins{ $_ }->{ 'tip' } );

			$model->set(
						 $model->append,               0,
						 $pixbuf,                      1,
						 $plugins{ $_ }->{ 'name' },   2,
						 $plugins{ $_ }->{ 'binary' }, 3,
						 $plugins{ $_ }->{ 'lang' },   4,
						 $plugins{ $_ }->{ 'tip' },    5,
						 $_
					   );
		} else {
			print "WARNING: Program $_ is not configured properly, ignoring\n";
		}
	}
	my $plugin       = Gtk2::ComboBox->new( $model );
	my $plugin_descr = Gtk2::Label->new;
	$plugin_descr->set_line_wrap( TRUE );
	$plugin_descr->set_line_wrap_mode( 'word' );
	$plugin_descr->set_width_chars( 30 );
	$plugin_descr->set_padding( 10, 10 );
	my $plugin_image       = Gtk2::Image->new;
	my $plugin_descr_frame = Gtk2::Frame->new( $d->get( "Description" ) );
	$plugin_descr_frame->add( $plugin_descr );
	my $plugin_hbox = Gtk2::HBox->new( FALSE, 5 );
	$plugin_hbox->set_border_width( 10 );

	$plugin->signal_connect(
		'changed' => sub {

			my $model       = $plugin->get_model();
			my $plugin_iter = $plugin->get_active_iter();

			if ( $plugin_iter ) {
				my $plugin_pixbuf = $model->get_value( $plugin_iter, 0 );
				my $plugin_name   = $model->get_value( $plugin_iter, 1 );
				my $plugin_value  = $model->get_value( $plugin_iter, 2 );
				my $plugin_lang   = $model->get_value( $plugin_iter, 3 );
				my $plugin_tip    = $model->get_value( $plugin_iter, 4 );
				my $plugin_key    = $model->get_value( $plugin_iter, 5 );

				$plugin_descr->set_text( $plugin_tip );
				$plugin_image->set_from_pixbuf(
									  Gtk2::Gdk::Pixbuf->new_from_file_at_size(
										  $plugins{ $plugin_key }->{ 'pixbuf' },
										  100, 100
									  )
				);
			}
		},
		'changed'
						   );
	my $renderer_pix = Gtk2::CellRendererPixbuf->new;
	$plugin->pack_start( $renderer_pix, FALSE );
	$plugin->add_attribute( $renderer_pix, pixbuf => 0 );
	my $renderer_text = Gtk2::CellRendererText->new;
	$plugin->pack_start( $renderer_text, FALSE );
	$plugin->add_attribute( $renderer_text, text => 1 );
	$plugin->set_active( 0 );
	$plugin_dialog->vbox->add( $plugin );
	$plugin_dialog->vbox->add( $plugin_hbox );
	$plugin_hbox->pack_start_defaults( $plugin_image );
	$plugin_hbox->pack_start_defaults( $plugin_descr_frame );
	$plugin_dialog->show_all;
	my $plugin_response = $plugin_dialog->run;

	if ( $plugin_response eq "accept" ) {
		$dlg_plugin_text = &fct_switch_home_in_file( $dlg_plugin_text );
		my $model        = $plugin->get_model();
		my $plugin_iter  = $plugin->get_active_iter();
		my $plugin_value = $model->get_value( $plugin_iter, 2 );
		my $plugin_name  = $model->get_value( $plugin_iter, 1 );
		my $plugin_lang  = $model->get_value( $plugin_iter, 3 );
		unless ( $plugin_value =~ /[a-zA-Z0-9]+/ ) {
			&dlg_error_message( $d->get( "No plugin specified" ) );
			return FALSE;
		}

		my $data =
			[ $plugin_value, $plugin_name, $plugin_lang, $key, $plugin_dialog ];
		&fct_execute_plugin( undef, $data );

		$plugin_dialog->destroy();
		return TRUE;
	} else {
		$plugin_dialog->destroy();
		return FALSE;
	}
}

sub dlg_account_chooser_and_upload {
	my ( $file_to_upload ) = @_;
	my $dlg_header         = $d->get( "Choose hosting-site and account" );
	my $hosting_dialog     = Gtk2::Dialog->new( $dlg_header, $window,
											[ qw/modal destroy-with-parent/ ] );
	my $upload_button =
		$hosting_dialog->add_button( $d->get( "_Upload" ), 'accept' );
	$upload_button->set_image(
						 Gtk2::Image->new_from_stock( 'gtk-go-up', 'button' ) );
	$hosting_dialog->add_button( 'gtk-cancel', 'reject' );
	$hosting_dialog->set_default_response( 'accept' );
	$hosting_dialog->set_size_request( 300 );
	my $model =
		Gtk2::ListStore->new( 'Glib::String', 'Glib::String', 'Glib::String' );

	foreach ( keys %accounts ) {
		$model->set(
					 $model->append,                  0,
					 $accounts{ $_ }->{ 'host' },     1,
					 $accounts{ $_ }->{ 'username' }, 2,
					 $accounts{ $_ }->{ 'password' }
				   )
			if (
				( $_ =~ /imageshack/i && $accounts{ $_ }->{ 'username' } ne "" )
				|| (    $accounts{ $_ }->{ 'username' } ne ""
					 && $accounts{ $_ }->{ 'password' } ne "" )
			   );
		$model->set( $model->append, 0, $accounts{ $_ }->{ 'host' },
					 1, $d->get( "Guest" ),
					 2, "" );
	}
	my $hosting_image = Gtk2::Image->new;
	my $hosting_hbox = Gtk2::HBox->new( FALSE, 5 );
	$hosting_hbox->set_border_width( 10 );
	my $hosting       = Gtk2::ComboBox->new( $model );
	my $renderer_host = Gtk2::CellRendererText->new;
	$hosting->pack_start( $renderer_host, FALSE );
	$hosting->add_attribute( $renderer_host, text => 0 );
	my $renderer_username = Gtk2::CellRendererText->new;
	$hosting->pack_start( $renderer_username, FALSE );
	$hosting->add_attribute( $renderer_username, text => 1 );
	$hosting->signal_connect(
		'changed' => sub {

			my $model        = $hosting->get_model();
			my $hosting_iter = $hosting->get_active_iter();

			if ( $hosting_iter ) {
				my $hosting_host     = $model->get_value( $hosting_iter, 0 );
				my $hosting_username = $model->get_value( $hosting_iter, 1 );
				if ( $hosting_host =~ /imageshack/i ) {
					$hosting_image->set_from_pixbuf(
						Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
							"$gscrot_root/share/gscrot/resources/icons/logo-imageshack.png",
							200,
							200,
							TRUE
						)
					);
				} elsif ( $hosting_host =~ /imagebanana/i ) {
					$hosting_image->set_from_pixbuf(
						Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
							"$gscrot_root/share/gscrot/resources/icons/logo-imagebanana.png",
							200,
							200,
							TRUE
						)
					);
				} elsif ( $hosting_host =~ /ubuntu-pics/i ) {
					$hosting_image->set_from_pixbuf(
						Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
							"$gscrot_root/share/gscrot/resources/icons/logo-ubuntu-pics.png",
							200,
							200,
							TRUE
						)
					);
				}

			}
		},
		'changed'
							);

	$hosting->set_active( 0 );
	$hosting_dialog->vbox->add( $hosting );
	$hosting_dialog->vbox->add( $hosting_hbox );
	$hosting_hbox->pack_start_defaults( $hosting_image );
	$hosting_dialog->show_all;
	my $hosting_response = $hosting_dialog->run;

	if ( $hosting_response eq "accept" ) {
		my $model            = $hosting->get_model();
		my $hosting_iter     = $hosting->get_active_iter();
		my $hosting_host     = $model->get_value( $hosting_iter, 0 );
		my $hosting_username = $model->get_value( $hosting_iter, 1 );
		my $hosting_password = $model->get_value( $hosting_iter, 2 );
		if ( $hosting_host eq "ubuntu-pics.de" ) {
			my %upload_response;
			%upload_response =
				&fct_upload_ubuntu_pics(
							&fct_switch_home_in_file( $file_to_upload ),
							$hosting_username, $hosting_password, $debug_cparam,
							GSCROT_VERSION );
			if ( is_success( $upload_response{ 'status' } ) ) {
				&dlg_upload_links_ubuntu_pics(
											   $hosting_host,
											   $hosting_username,
											   $upload_response{ 'thumb1' },
											   $upload_response{ 'thumb2' },
											   $upload_response{ 'bbcode' },
											   $upload_response{ 'ubuntucode' },
											   $upload_response{ 'direct' },
											   $upload_response{ 'status' }
											 );
				&dlg_status_message( 1,
								$file_to_upload . " " . $d->get( "uploaded" ) );
			} else {
				&dlg_error_message( $upload_response{ 'status' } );
			}
		} elsif ( $hosting_host eq "imagebanana.com" ) {
			my %upload_response;
			%upload_response =
				&fct_upload_imagebanana(
							&fct_switch_home_in_file( $file_to_upload ),
							$hosting_username, $hosting_password, $debug_cparam,
							GSCROT_VERSION );
			if ( is_success( $upload_response{ 'status' } ) ) {
				&dlg_upload_links_imagebanana(
											   $hosting_host,
											   $hosting_username,
											   $upload_response{ 'thumb1' },
											   $upload_response{ 'thumb2' },
											   $upload_response{ 'thumb3' },
											   $upload_response{ 'friends' },
											   $upload_response{ 'popup' },
											   $upload_response{ 'direct' },
											   $upload_response{ 'hotweb' },
											   $upload_response{ 'hotboard1' },
											   $upload_response{ 'hotboard2' },
											   $upload_response{ 'status' }
											 );
				&dlg_status_message( 1,
								$file_to_upload . " " . $d->get( "uploaded" ) );
			} else {
				&dlg_error_message( $upload_response{ 'status' } );
			}
		} elsif ( $hosting_host eq "imageshack.us" ) {
			my $ishack = GScrot::ImageShack->new();

			#login
			eval { $ishack->login( $hosting_username ); };
			if ( $@ ) {
				&dlg_error_message( "Login failed!\nPleas try again later\n" );
				$hosting_dialog->destroy();
				return TRUE;
			}

			#upload
			my $url = undef;
			eval { $url = $ishack->host( $file_to_upload, undef ); };
			if ( $@ ) {
				&dlg_error_message( "Upload failed!\nPleas try again later\n" );
				$hosting_dialog->destroy();
				return TRUE;
			}

			#get thumbnail url
			my $thumb_url = undef;
			eval { $thumb_url = $ishack->hosted_thumb; };
			if ( $@ ) {
				&dlg_info_message(
					"ImageShack does not generate thumbs for images that are 200x200 pixels in resolution or less"
				);
			}

			if ( $url ) {
				&dlg_upload_links_imageshack( $hosting_host, $hosting_username,
											  $url, $thumb_url, RC_OK );
				&dlg_status_message( 1,
								$file_to_upload . " " . $d->get( "uploaded" ) );
			} else {
				&dlg_error_message( "Upload failed!\nPleas try again later\n" );
			}

		}
		$hosting_dialog->destroy();
		return TRUE;
	} else {
		$hosting_dialog->destroy();
		return FALSE;
	}
}

sub dlg_website {
	my $dlg_header = $d->get( "URL to capture" );
	my $website_dialog =
		Gtk2::Dialog->new(
						   $dlg_header,
						   $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-ok'     => 'accept',
						   'gtk-cancel' => 'reject'
						 );
	$website_dialog->set_default_response( 'accept' );
	my $website = Gtk2::Entry->new;
	$website->set_text( "http://" );
	$website->set_activates_default( TRUE );
	my $clipboard_string = $clipboard->wait_for_text;
	print "Content of clipboard is: $clipboard_string\n" if $debug_cparam;

	if ( defined $clipboard_string ) {
		if (    $clipboard_string =~ /^http/
			 || $clipboard_string =~ /^file/
			 || $clipboard_string =~ /^www\./ )
		{
			$website->set_text( $clipboard_string );
		}
	}
	$website_dialog->vbox->add( $website );
	$website_dialog->show_all;
	my $website_response = $website_dialog->run;

	if ( $website_response eq "accept" ) {
		$website_dialog->destroy();
		return $website->get_text;
	} else {
		$website_dialog->destroy();
		return FALSE;
	}
}

sub dlg_upload_links_ubuntu_pics {
	my (
		 $host,   $username,   $thumb1, $thumb2,
		 $bbcode, $ubuntucode, $direct, $status
	   ) = @_;
	my $dlg_header = $d->get( "Upload" ) . " - " . $host . " - " . $username;
	my $upload_dialog =
		Gtk2::Dialog->new( $dlg_header, $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-ok' => 'accept' );
	$upload_dialog->set_default_response( 'accept' );

	my $upload_hbox   = Gtk2::HBox->new( FALSE, 0 );
	my $upload_hbox1  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox2  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox3  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox4  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox5  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox6  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox7  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox8  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox9  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox10 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_vbox   = Gtk2::VBox->new( FALSE, 0 );

	my $label_status = Gtk2::Label->new(
				$d->get( "Upload status:" ) . " " . status_message( $status ) );

	$upload_hbox->pack_start(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
				"$gscrot_root/share/gscrot/resources/icons/logo-ubuntu-pics.png",
				100,
				100,
				TRUE
			)
		),
		TRUE, TRUE, 0
	);
	$upload_hbox->pack_start( $label_status, TRUE, TRUE, 0 );
	my $entry_thumb1     = Gtk2::Entry->new();
	my $entry_thumb2     = Gtk2::Entry->new();
	my $entry_bbcode     = Gtk2::Entry->new();
	my $entry_ubuntucode = Gtk2::Entry->new();
	my $entry_direct     = Gtk2::Entry->new();
	my $label_thumb1 =
		Gtk2::Label->new( $d->get( "Thumbnail for websites (with border)" ) );
	my $label_thumb2 = Gtk2::Label->new(
						 $d->get( "Thumbnail for websites (without border)" ) );
	my $label_bbcode = Gtk2::Label->new( $d->get( "Thumbnail for forums" ) );
	my $label_ubuntucode =
		Gtk2::Label->new( $d->get( "Thumbnail for Ubuntuusers.de forum" ) );
	my $label_direct = Gtk2::Label->new( $d->get( "Direct link" ) );
	$entry_thumb1->set_text( $thumb1 );
	$entry_thumb2->set_text( $thumb2 );
	$entry_bbcode->set_text( $bbcode );
	$entry_ubuntucode->set_text( $ubuntucode );
	$entry_direct->set_text( $direct );

	my $tooltip_copy = Gtk2::Tooltips->new;
	my $upload_copy1 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy1,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy1->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy1->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_thumb1
								 );


	my $upload_copy2 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy2,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy2->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy2->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_thumb2
								 );

	my $upload_copy3 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy3,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy3->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy3->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_bbcode
								 );
	my $upload_copy4 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy4,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy4->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy4->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_ubuntucode
								 );
	my $upload_copy5 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy5,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy5->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy5->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_direct
								 );


	$upload_hbox1->pack_start_defaults( $label_thumb1 );
	$upload_hbox1->pack_start_defaults( $entry_thumb1 );
	$upload_hbox2->pack_start_defaults( $upload_hbox1 );
	$upload_hbox2->pack_start( $upload_copy1, FALSE, TRUE, 10 );

	$upload_hbox3->pack_start_defaults( $label_thumb2 );
	$upload_hbox3->pack_start_defaults( $entry_thumb2 );
	$upload_hbox4->pack_start_defaults( $upload_hbox3 );
	$upload_hbox4->pack_start( $upload_copy2, FALSE, TRUE, 10 );

	$upload_hbox5->pack_start_defaults( $label_bbcode );
	$upload_hbox5->pack_start_defaults( $entry_bbcode );
	$upload_hbox6->pack_start_defaults( $upload_hbox5 );
	$upload_hbox6->pack_start( $upload_copy3, FALSE, TRUE, 10 );

	$upload_hbox7->pack_start_defaults( $label_ubuntucode );
	$upload_hbox7->pack_start_defaults( $entry_ubuntucode );
	$upload_hbox8->pack_start_defaults( $upload_hbox7 );
	$upload_hbox8->pack_start( $upload_copy4, FALSE, TRUE, 10 );

	$upload_hbox9->pack_start_defaults( $label_direct );
	$upload_hbox9->pack_start_defaults( $entry_direct );
	$upload_hbox10->pack_start_defaults( $upload_hbox9 );
	$upload_hbox10->pack_start( $upload_copy5, FALSE, TRUE, 10 );

	$upload_vbox->pack_start( $upload_hbox, TRUE, TRUE, 10 );
	$upload_vbox->pack_start_defaults( $upload_hbox2 );
	$upload_vbox->pack_start_defaults( $upload_hbox4 );
	$upload_vbox->pack_start_defaults( $upload_hbox6 );
	$upload_vbox->pack_start_defaults( $upload_hbox8 );
	$upload_vbox->pack_start_defaults( $upload_hbox10 );

	$upload_dialog->vbox->add( $upload_vbox );
	$upload_dialog->show_all;
	my $upload_response = $upload_dialog->run;

	if ( $upload_response eq "accept" ) {
		$upload_dialog->destroy();
		return TRUE;
	} else {
		$upload_dialog->destroy();
		return FALSE;
	}
}

sub dlg_upload_links_imagebanana {
	my (
		 $host,   $username,  $thumb1,    $thumb2,
		 $thumb3, $friends,   $popup,     $direct,
		 $hotweb, $hotboard1, $hotboard2, $status
	   ) = @_;
	my $dlg_header = $d->get( "Upload" ) . " - " . $host . " - " . $username;
	my $upload_dialog =
		Gtk2::Dialog->new( $dlg_header, $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-ok' => 'accept' );
	$upload_dialog->set_default_response( 'accept' );

	my $upload_hbox = Gtk2::HBox->new( FALSE, 0 );
	my $upload_hbox1  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox2  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox3  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox4  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox5  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox6  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox7  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox8  = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox9  = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox10 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox11 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox12 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox13 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox14 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox15 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox16 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox17 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox18 = Gtk2::HBox->new( FALSE, 10 );

	my $upload_vbox = Gtk2::VBox->new( FALSE, 0 );

	my $label_status = Gtk2::Label->new(
				$d->get( "Upload status:" ) . " " . status_message( $status ) );

	$upload_hbox->pack_start(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
				"$gscrot_root/share/gscrot/resources/icons/logo-imagebanana.png",
				100,
				100,
				TRUE
			)
		),
		TRUE, TRUE, 0
	);
	$upload_hbox->pack_start( $label_status, TRUE, TRUE, 0 );

	my $entry_thumb1    = Gtk2::Entry->new;
	my $entry_thumb2    = Gtk2::Entry->new;
	my $entry_thumb3    = Gtk2::Entry->new;
	my $entry_friends   = Gtk2::Entry->new;
	my $entry_popup     = Gtk2::Entry->new;
	my $entry_direct    = Gtk2::Entry->new;
	my $entry_hotweb    = Gtk2::Entry->new;
	my $entry_hotboard1 = Gtk2::Entry->new;
	my $entry_hotboard2 = Gtk2::Entry->new;
	$entry_thumb1->set_text( $thumb1 );
	$entry_thumb2->set_text( $thumb2 );
	$entry_thumb3->set_text( $thumb3 );
	$entry_friends->set_text( $friends );
	$entry_popup->set_text( $popup );
	$entry_direct->set_text( $direct );
	$entry_hotweb->set_text( $hotweb );
	$entry_hotboard1->set_text( $hotboard1 );
	$entry_hotboard2->set_text( $hotboard2 );

	my $tooltip_copy = Gtk2::Tooltips->new;
	my $upload_copy1 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy1,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy1->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy1->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_thumb1
								 );


	my $upload_copy2 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy2,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy2->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy2->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_thumb2
								 );

	my $upload_copy3 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy3,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy3->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy3->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_thumb3
								 );
	my $upload_copy4 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy4,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy4->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy4->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_friends
								 );
	my $upload_copy5 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy5,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy5->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy5->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_popup
								 );

	my $upload_copy6 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy6,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy6->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy6->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_direct
								 );


	my $upload_copy7 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy7,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy7->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy7->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_hotweb
								 );

	my $upload_copy8 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy8,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy8->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy8->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_hotboard1
								 );

	my $upload_copy9 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy9,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy9->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy9->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_hotboard2
								 );


	$upload_vbox->pack_start( $upload_hbox, TRUE, TRUE, 10 );

	$upload_hbox1->pack_start_defaults(
					  Gtk2::Label->new( $d->get( "Thumbnail for websites" ) ) );
	$upload_hbox1->pack_start_defaults( $entry_thumb1 );
	$upload_hbox2->pack_start_defaults( $upload_hbox1 );
	$upload_hbox2->pack_start( $upload_copy1, FALSE, TRUE, 10 );

	$upload_hbox3->pack_start_defaults(
					Gtk2::Label->new( $d->get( "Thumbnail for boards (1)" ) ) );
	$upload_hbox3->pack_start_defaults( $entry_thumb2 );
	$upload_hbox4->pack_start_defaults( $upload_hbox3 );
	$upload_hbox4->pack_start( $upload_copy2, FALSE, TRUE, 10 );

	$upload_hbox5->pack_start_defaults(
					Gtk2::Label->new( $d->get( "Thumbnail for boards (2)" ) ) );
	$upload_hbox5->pack_start_defaults( $entry_thumb3 );
	$upload_hbox6->pack_start_defaults( $upload_hbox5 );
	$upload_hbox6->pack_start( $upload_copy3, FALSE, TRUE, 10 );

	$upload_hbox7->pack_start_defaults(
						   Gtk2::Label->new( $d->get( "Show your friends" ) ) );
	$upload_hbox7->pack_start_defaults( $entry_friends );
	$upload_hbox8->pack_start_defaults( $upload_hbox7 );
	$upload_hbox8->pack_start( $upload_copy4, FALSE, TRUE, 10 );

	$upload_hbox9->pack_start_defaults(
						  Gtk2::Label->new( $d->get( "Popup for websites" ) ) );
	$upload_hbox9->pack_start_defaults( $entry_popup );
	$upload_hbox10->pack_start_defaults( $upload_hbox9 );
	$upload_hbox10->pack_start( $upload_copy5, FALSE, TRUE, 10 );

	$upload_hbox11->pack_start_defaults(
								 Gtk2::Label->new( $d->get( "Direct link" ) ) );
	$upload_hbox11->pack_start_defaults( $entry_direct );
	$upload_hbox12->pack_start_defaults( $upload_hbox11 );
	$upload_hbox12->pack_start( $upload_copy6, FALSE, TRUE, 10 );

	$upload_hbox13->pack_start_defaults(
						Gtk2::Label->new( $d->get( "Hotlink for websites" ) ) );
	$upload_hbox13->pack_start_defaults( $entry_hotweb );
	$upload_hbox14->pack_start_defaults( $upload_hbox13 );
	$upload_hbox14->pack_start( $upload_copy7, FALSE, TRUE, 10 );

	$upload_hbox15->pack_start_defaults(
					  Gtk2::Label->new( $d->get( "Hotlink for boards (1)" ) ) );
	$upload_hbox15->pack_start_defaults( $entry_hotboard1 );
	$upload_hbox16->pack_start_defaults( $upload_hbox15 );
	$upload_hbox16->pack_start( $upload_copy8, FALSE, TRUE, 10 );

	$upload_hbox17->pack_start_defaults(
					  Gtk2::Label->new( $d->get( "Hotlink for boards (2)" ) ) );
	$upload_hbox17->pack_start_defaults( $entry_hotboard2 );
	$upload_hbox18->pack_start_defaults( $upload_hbox17 );
	$upload_hbox18->pack_start( $upload_copy9, FALSE, TRUE, 10 );

	$upload_vbox->pack_start_defaults( $upload_hbox2 );
	$upload_vbox->pack_start_defaults( $upload_hbox4 );
	$upload_vbox->pack_start_defaults( $upload_hbox6 );
	$upload_vbox->pack_start_defaults( $upload_hbox8 );
	$upload_vbox->pack_start_defaults( $upload_hbox10 );
	$upload_vbox->pack_start_defaults( $upload_hbox12 );
	$upload_vbox->pack_start_defaults( $upload_hbox14 );
	$upload_vbox->pack_start_defaults( $upload_hbox16 );
	$upload_vbox->pack_start_defaults( $upload_hbox18 );

	$upload_dialog->vbox->add( $upload_vbox );
	$upload_dialog->show_all;
	my $upload_response = $upload_dialog->run;

	if ( $upload_response eq "accept" ) {
		$upload_dialog->destroy();
		return TRUE;
	} else {
		$upload_dialog->destroy();
		return FALSE;
	}
}

sub dlg_upload_links_imageshack {
	my ( $host, $username, $url, $url_thumb, $status ) = @_;
	my $dlg_header = $d->get( "Upload" ) . " - " . $host . " - " . $username;
	my $upload_dialog =
		Gtk2::Dialog->new( $dlg_header, $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-ok' => 'accept' );
	$upload_dialog->set_default_response( 'accept' );

	my $upload_hbox  = Gtk2::HBox->new( FALSE, 0 );
	my $upload_hbox1 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox2 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox3 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox4 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox5 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox6 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_hbox7 = Gtk2::HBox->new( TRUE,  10 );
	my $upload_hbox8 = Gtk2::HBox->new( FALSE, 10 );
	my $upload_vbox  = Gtk2::VBox->new( FALSE, 0 );
	my $label_status = Gtk2::Label->new(
				$d->get( "Upload status:" ) . " " . status_message( $status ) );

	$upload_hbox->pack_start(
		Gtk2::Image->new_from_pixbuf(
			Gtk2::Gdk::Pixbuf->new_from_file_at_scale(
				"$gscrot_root/share/gscrot/resources/icons/logo-imageshack.png",
				100,
				100,
				TRUE
			)
		),
		TRUE, TRUE, 0
	);
	$upload_hbox->pack_start( $label_status, TRUE, TRUE, 0 );

	my $entry_direct = Gtk2::Entry->new();
	my $entry_hotweb = Gtk2::Entry->new();
	my $label_thumb1 = Gtk2::Label->new( $d->get( "Thumbnail for websites" ) );
	my $label_thumb2 = Gtk2::Label->new( $d->get( "Thumbnail for forums" ) );
	my $label_direct = Gtk2::Label->new( $d->get( "Direct link" ) );
	my $label_hotweb = Gtk2::Label->new( $d->get( "Hotlink for websites" ) );

	$entry_direct->set_text( "$url" );
	$entry_hotweb->set_text(
		"<a href=\"http:\/\/imageshack.us\"><img src=\"$url\" border=\"0\" alt=\"Image Hosted by ImageShack.us\"\/><\/a><br\/>By <a href=\"https:\/\/launchpad.net\/gscrot\">GScrot<\/a>"
	);
	$upload_vbox->pack_start( $upload_hbox, TRUE, TRUE, 10 );

	my $tooltip_copy = Gtk2::Tooltips->new;

	if ( $url_thumb ) {
		my $entry_thumb1 = Gtk2::Entry->new();
		my $entry_thumb2 = Gtk2::Entry->new();

		my $upload_copy1 = Gtk2::Button->new;
		$tooltip_copy->set_tip( $upload_copy1,
								$d->get( "Copy this code to clipboard" ) );
		$upload_copy1->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
		$upload_copy1->signal_connect(
			'clicked' => sub {
				my ( $widget, $entry ) = @_;
				$clipboard->set_text( $entry->get_text );
			},
			$entry_thumb1
									 );

		my $upload_copy2 = Gtk2::Button->new;
		$tooltip_copy->set_tip( $upload_copy2,
								$d->get( "Copy this code to clipboard" ) );
		$upload_copy2->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
		$upload_copy2->signal_connect(
			'clicked' => sub {
				my ( $widget, $entry ) = @_;
				$clipboard->set_text( $entry->get_text );
			},
			$entry_thumb2
									 );

		$entry_thumb1->set_text(
			"<a href=\"$url\"><img src=\"$url_thumb\" border=\"0\" alt=\"Image Hosted by ImageShack.us\"\/><\/a>"
		);
		$entry_thumb2->set_text(
						   "\[url\=$url\]\[img\]$url_thumb\[\/img\]\[\/url\]" );
		$upload_hbox1->pack_start_defaults( $label_thumb1 );
		$upload_hbox1->pack_start_defaults( $entry_thumb1 );
		$upload_hbox2->pack_start_defaults( $upload_hbox1 );
		$upload_hbox2->pack_start( $upload_copy1, FALSE, TRUE, 10 );
		$upload_hbox3->pack_start_defaults( $label_thumb2 );
		$upload_hbox3->pack_start_defaults( $entry_thumb2 );
		$upload_hbox4->pack_start_defaults( $upload_hbox3 );
		$upload_hbox4->pack_start( $upload_copy2, FALSE, TRUE, 10 );

	}

	my $upload_copy3 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy3,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy3->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy3->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_direct
								 );

	my $upload_copy4 = Gtk2::Button->new;
	$tooltip_copy->set_tip( $upload_copy4,
							$d->get( "Copy this code to clipboard" ) );
	$upload_copy4->set_image(
							Gtk2::Image->new_from_stock( 'gtk-copy', 'menu' ) );
	$upload_copy4->signal_connect(
		'clicked' => sub {
			my ( $widget, $entry ) = @_;
			$clipboard->set_text( $entry->get_text );
		},
		$entry_hotweb
								 );

	$upload_hbox5->pack_start_defaults( $label_direct );
	$upload_hbox5->pack_start_defaults( $entry_direct );
	$upload_hbox6->pack_start_defaults( $upload_hbox5 );
	$upload_hbox6->pack_start( $upload_copy3, FALSE, TRUE, 10 );
	$upload_hbox7->pack_start_defaults( $label_hotweb );
	$upload_hbox7->pack_start_defaults( $entry_hotweb );
	$upload_hbox8->pack_start_defaults( $upload_hbox7 );
	$upload_hbox8->pack_start( $upload_copy4, FALSE, TRUE, 10 );

	$upload_vbox->pack_start_defaults( $upload_hbox2 );
	$upload_vbox->pack_start_defaults( $upload_hbox4 );
	$upload_vbox->pack_start_defaults( $upload_hbox6 );
	$upload_vbox->pack_start_defaults( $upload_hbox8 );

	$upload_dialog->vbox->add( $upload_vbox );
	$upload_dialog->show_all;
	my $upload_response = $upload_dialog->run;

	if ( $upload_response eq "accept" ) {
		$upload_dialog->destroy();
		return TRUE;
	} else {
		$upload_dialog->destroy();
		return FALSE;
	}
}

sub dlg_info_message {
	my ( $dlg_info_message ) = @_;
	my $info_dialog =
		Gtk2::MessageDialog->new( $window, [ qw/modal destroy-with-parent/ ],
								  'info', 'ok', $dlg_info_message );
	my $info_response = $info_dialog->run;
	$info_dialog->destroy() if ( $info_response eq "ok" );
	return TRUE;
}

sub dlg_profile_name {
	my ( $curr_profile_name, $combobox_settings_profiles ) = @_;
	my $dlg_header = $d->get( "Save as profile" );
	my $profile_dialog =
		Gtk2::Dialog->new(
						   $dlg_header,
						   $window,
						   [ qw/modal destroy-with-parent/ ],
						   'gtk-ok'     => 'accept',
						   'gtk-cancel' => 'reject'
						 );
	$profile_dialog->set_default_response( 'accept' );
	my $new_profile_name = Gtk2::Entry->new();
	$new_profile_name->set_activates_default( TRUE );
	$new_profile_name->set_text( $curr_profile_name )
		if defined $curr_profile_name;
	$profile_dialog->vbox->add( $new_profile_name );
	$profile_dialog->show_all;
	my $profile_response = $profile_dialog->run;

	if ( $profile_response eq "accept" ) {
		my $entered_name = $new_profile_name->get_text;

		if (
			 &fct_file_exists( "$ENV{'HOME'}/.gscrot/profiles/$entered_name.xml"
							 )
		   )
		{

			if (
				&dlg_question_message(
					$d->get(
						"Profile already exists.\nDo you want to overwrite the existing profile?"
					)
				)
			   )
			{
				$profile_dialog->destroy();
				return $new_profile_name->get_text;
			} else {
				$profile_dialog->destroy();
				return FALSE;
			}
		}

		$profile_dialog->destroy();
		return $new_profile_name->get_text;
	} else {
		$profile_dialog->destroy();
		return FALSE;
	}
}

#--------------------------------------
